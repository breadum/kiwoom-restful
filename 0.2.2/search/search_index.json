{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kiwoom REST API","text":"<p>Simple Python Wrapper for Kiwoom RESTful API   </p>"},{"location":"#what-is-it","title":"What is it?","text":"<ul> <li>\ud0a4\uc6c0\uc99d\uad8c\uc5d0\uc11c \uc81c\uacf5\ud558\ub294 'REST' API \uc778\ud130\ud398\uc774\uc2a4 \uc0ac\uc6a9\uc744 \uc704\ud55c \uac04\ub2e8\ud55c Python Wrapper \ubaa8\ub4c8</li> <li>\ub124\ud2b8\uc6cc\ud06c \ud504\ub85c\ud1a0\ucf5c \ub514\ud14c\uc77c\uc740 \uc228\uae30\uace0 \ud22c\uc790 \uc804\ub7b5 \ub85c\uc9c1\uc5d0 \uc9d1\uc911\ud560 \uc218 \uc788\ub3c4\ub85d \uc124\uacc4</li> <li>\uc9c1\uc811 \uac1c\ubc1c\ud558\uace0\uc790 \ud558\ub294 \uc0ac\ub78c\uc744 \uc704\ud55c \ubaa8\ub4c8\ub85c \ubd80\uac00\uc801\uc778 \uae30\ub2a5\uc740 \ucd5c\ub300\ud55c \ubc30\uc81c</li> <li>\ud604\uc7ac \uac1c\ubc1c \ub2e8\uacc4\ub294 RC(Release Candidate)\ub85c \uad6c\uc870\uc801\uc778 \uc124\uacc4 \ub9c8\ubb34\ub9ac \ub2e8\uacc4</li> <li>'REST' API\uac00 \uc544\ub2cc \uae30\uc874 PyQt \uae30\ubc18 OCX \ubc29\uc2dd API\ub294 \uc774\uacf3\uc744 \ucc38\uc870</li> </ul>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Kiwoom REST API</li> <li>What is it?</li> <li>Table of Contents</li> <li>Features</li> <li>Installation</li> <li>Examples</li> <li>Architecture</li> <li>License</li> <li>Disclaimer</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>\uac04\uacb0\ud55c API\ub97c \ud1b5\ud55c \ube60\ub978 \ud504\ub85c\ud1a0 \ud0c0\uc785 \ubc0f \uc804\ub7b5 \ucd5c\uc801\ud654</li> <li>Async Http \uc694\uccad \ubc0f \uc751\ub2f5 + Websocket \ub370\uc774\ud130 \ucc98\ub9ac</li> <li>\uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ucc98\ub9ac\ub97c \uc704\ud55c non-\ube14\ub85c\ud0b9 \ucf5c\ubc31 \uc2dc\uc2a4\ud15c </li> <li>msgpsec / orjson \uae30\ubc18 \uc2e4\uc2dc\uac04 \uace0\uc18d json \ud30c\uc2f1</li> <li>\ucd08\ub2f9 Http \uc5f0\uacb0/\ud638\ucd9c \uc81c\ud55c \uc790\ub3d9\uad00\ub9ac</li> <li>Websocket ping-pong \uc790\ub3d9\ucc98\ub9ac</li> </ul> <p>\ubaa8\ub4c8 \uad00\ub828 \uc0c1\uc138\ud55c API \ubb38\uc11c \ud398\uc774\uc9c0\ub294 \uc774\uacf3\uc744 \ucc38\uace0\ud574 \uc8fc\uc138\uc694.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code># install from pypi\npip install -U kiwoom-restful\n\n# install from git fork/clone\npip install -e ,\n</code></pre> <p>Requirements  </p> <ul> <li>python 3.11+ recommended (at leaset 3.10+)  </li> <li>install uvloop is a plus for linux environment  </li> </ul> <pre><code>import asyncio, uvloop\nasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>\uae30\ubcf8\uc801\uc778 API \uad6c\ud604 \ubc0f Bot \ud65c\uc6a9\uc608\uc2dc</p> <pre><code>from kiwoom import API, Bot\nfrom kiwoom.http import Response\n\n# API \uc0c1\uc138 \uad6c\ud604\nclass MyAPI(API):\n    def __init__(self, host:str, appkey: str, secretkey: str):\n        super().__init__(host, appkey, secretkey)\n\n    # \uc99d\uad8c\uc0ac\ubcc4\ub9e4\ub9e4\uc0c1\uc704\uc694\uccad\n    async def what_stocks_ebest_bought_today(self) -&gt; list[dict]:\n        endpoint = '/api/dostk/rkinfo'\n        api_id = 'ka10039'\n        data = {\n            'mmcm_cd': '063',    # \ud68c\uc6d0\uc0ac\ucf54\ub4dc\n            'trde_qty_tp': '0',  # \uac70\ub798\ub7c9\uad6c\ubd84 (\uc804\uccb4 '0')\n            'trde_tp': '1',      # \ub9e4\ub9e4\uad6c\ubd84 (\uc21c\ub9e4\uc218 '1')    \n            'dt': '0',           # \uae30\uac04 (\ub2f9\uc77c '0')\n            'stex_tp': '3'       # \uac70\ub798\uc18c\uad6c\ubd84 (\ud1b5\ud569 '3')\n        }\n        # \ub2e4\uc74c \ub370\uc774\ud130\uac00 \uc788\uc73c\uba74 \ubb34\uc870\uac74 \uacc4\uc18d \uc694\uccad\n        should_continue = lambda res: True  \n        # \ud0a4\uc6c0 REST API \uc11c\ubc84 \uc751\ub2f5 \ub370\uc774\ud130 \ucde8\ud569 \ud6c4 \ubc18\ud658\n        res: dict = await self.request_until(\n            should_continue, \n            endpoint, \n            api_id, \n            data=data\n        )\n        key = 'sec_trde_upper'\n        if key in res:\n            return res[key]\n        return []  # or raise Exception\n\n# API \ud65c\uc6a9 \ud074\ub798\uc2a4\nclass MyBot(Bot):\n    def __init__(self, host: str, appkey: str, secretkey: str):\n        super().__init__(\n            host, appkey, secretkey, \n            api=MyAPI(host, appkey, secretkey) \n        )\n        self.blacklist: set[str] = set()\n\n    async def add_to_blacklist(self) -&gt; None:\n        data = await self.api.what_stocks_ebest_bought_today()\n        ETFs = (\"KODEX\", \"TIGER\", \"RISE\")\n        top10 = data[:10]\n        for item in top10:\n            # Roughly skip ETFs\n            name = item[\"stk_nm\"]\n            if any(etf in name for etf in ETFs):\n                continue\n\n            self.blacklist.add(item[\"stk_cd\"])\n</code></pre> <p>Bot \uae30\ubcf8 \ub0b4\uc7a5\ud568\uc218 2\uac00\uc9c0 \ud65c\uc6a9\uc608\uc2dc</p> <pre><code>import asyncio\nfrom kiwoom import Bot\nfrom kiwoom.proc import candle, trade\n\nclass MyBot(Bot):\n    async def run():\n        # \ubd84\ubd09\ucc28\ud2b8 \ub370\uc774\ud130\n        code = '005930_AL'  # \uac70\ub798\uc18c \ud1b5\ud569\ucf54\ub4dc\n        df = await self.candle(\n                code=code, \n                period='min',   # 'tick' | 'min' | 'day'\n                ctype='stock',  # 'stock' | 'sector'\n                start='20250901',\n                end='',\n        )\n        await candle.to_csv(file=f'{code}.csv', path='./', df)\n\n        # \uacc4\uc88c \uccb4\uacb0\ub0b4\uc5ed \ub370\uc774\ud130 (\ucd5c\uadfc 2\ub2ec\ub9cc)\n        fmt = '%Y%m%d'\n        today = datetime.today()\n        start = today - timedelta(days=60)\n        start = start.strftime(fmt)\n        end = end.strftime(fmt)\n        trs = self.trade(start, end)\n\n        # \ud0a4\uc6c0\uc99d\uad8c 0343 \ub9e4\ub9e4\ub0b4\uc5ed \ud654\uba74 \uc2a4\ud0c0\uc77c\ub85c \uc800\uc7a5\n        await trade.to_csv('trade.csv', './', trs)\n</code></pre> <p>Websocket \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \uc694\uccad \uad6c\ud604\uc608\uc2dc</p> <pre><code>import asyncio\nimport orjson\nimport pandas as pd\nfrom kiwoom import Bot\n\nclass MyBot(Bot):\n    def __init__(self, host: str, appkey: str, secretkey: str):\n        super().__init__(host, appkey, secretkey)\n        self.ticks: list[dict[str, str]] = []\n\n    async def on_receive_order_book(raw: str):\n        # \ud638\uac00 \ub370\uc774\ud130 \ucc98\ub9ac \ucf5c\ubc31\ud568\uc218 \uc608\uc2dc\n        # msg = json.loads(raw) # slow\n        msg = orjson.loads(raw) # fast\n        print(\n            f\"\uc885\ubaa9\ucf54\ub4dc: {msg['item']}, \"\n            f\"\ucd5c\uc6b0\uc120\ub9e4\ub3c4\ud638\uac00: {msg['values']['41']}\"\n            f\"\ucd5c\uc6b0\uc120\ub9e4\uc218\ud638\uac00: {msg['values']['51']}\"\n        )\n\n    async def on_receive_tick(raw: str):\n        # \uccb4\uacb0 \ub370\uc774\ud130 \ucc98\ub9ac \ucf5c\ubc31\ud568\uc218 \uc608\uc2dc\n        self.list.append(orjson.loads(raw))\n        if len(self.list) &gt;= 100:\n            df = pd.DataFrame(self.list)\n            print(df)\n\n    async def run():\n        # \uac70\ub798\uc18c \ud1b5\ud569 \uc885\ubaa9\ucf54\ub4dc \ubc1b\uc544\uc624\uae30 \n        kospi, kosdaq = '0', '10'\n        kospi_codes = await bot.stock_list(kospi, ats=True)\n        kosdaq_codes = await bot.stock_list(kosdaq, ats=True)\n\n        # \ud638\uac00 \ub370\uc774\ud130 \uc218\uc2e0 \uc2dc \ucf5c\ubc31 \ub4f1\ub85d\n        self.api.add_callback_on_real_data(\n            real_type=\"0D\",  # \uc2e4\uc2dc\uac04\uc2dc\uc138 &gt; \uc8fc\uc2dd\ud638\uac00\uc794\ub7c9\n            callback=self.on_receive_order_book\n        )\n        # \uccb4\uacb0 \ub370\uc774\ud130 \uc218\uc2e0 \uc2dc \ucf5c\ubc31 \ub4f1\ub85d\n        self.api.add_callback_on_real_data(\n            real_tyle=\"0B\",  # \uc2e4\uc2dc\uac04\uc2dc\uc138 &gt; \uc8fc\uc2dd\uccb4\uacb0\n            callback=self.on_receive_tick\n        )\n\n        # \ub370\uc774\ud130 \uc218\uc2e0\uc744 \uc704\ud55c \uc11c\ubc84 \uc694\uccad\n        # &gt; \ub370\uc774\ud130\uac00 \uc218\uc2e0\ub418\uba74 \uc790\ub3d9\uc73c\ub85c \ucf5c\ubc31\uc774 \ud638\ucd9c\ub428\n        # &gt; grp_no(\uadf8\ub8f9 \ubc88\ud638) \ubcc4 \uc885\ubaa9\ucf54\ub4dc(\ucd5c\ub300 100\uac1c) \uad00\ub9ac \ud544\uc694\n        codes1 = kospi_codes[:100]  \n        await self.api.register_hoga(grp_no='1', codes=codes1)\n        await self.api.register_tick(grp_no='1', codes=codes1)\n\n        codes2 = kosdaq_codes[:100]\n        await self.api.register_hoga(grp_no='2', codes=codes2)\n\n        codes3 = kospi_codes[100:200]\n        await self.api.register_tick(grp_no='3', codes=codes1)\n\n        # \ub370\uc774\ud130 \uc218\uc2e0 \ud574\uc81c\n        await self.api.remove_register(grp_no='1', type=['0B', '0D'])  \n        await self.api.remove_register(grp_no='2', type='0D')  # \ud638\uac00 '0D'\n        await self.api.remove_register(grp_no='3', type='0B')  # \uccb4\uacb0 '0B'\n</code></pre> <p>\uc2e4\uc81c \uc6b4\uc601\uc744 \uc704\ud55c \uc2a4\ud06c\ub9bd\ud2b8 \uc608\uc2dc</p> <pre><code>import asyncio\nfrom kiwoom import Bot, REAL\n\nasync def main():\n    # appkey, secretkey \ud30c\uc77c \uc704\uce58 \uc608\uc2dc\n    appkey = \"../keys/appkey.txt\"\n    secretkey = \"../keys/secretkey.txt\"\n\n    # context \uc0ac\uc6a9\uc744 \ud1b5\ud55c \uc5f0\uacb0 \ubc0f \ub9ac\uc18c\uc2a4 \uad00\ub9ac\n    async with MyBot(host=REAL, appkey, secretkey) as bot:\n        bot.debug(True)  # \uc694\uccad \ubc0f \uc751\ub2f5 \ud504\ub9b0\ud2b8\n        await bot.connect()\n        await bot.run()\n\n    # context \uc678\ubd80\ub294 \uc790\ub3d9 \uc5f0\uacb0 \ud574\uc81c\n    print('Done')\n\nif __name__ == '__main__':\n    asyncio.run(main())\n\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>Layered Roles  </p> <ul> <li>Client : Http \uc694\uccad \ud69f\uc218 \uc81c\ud55c \uad00\ub9ac \ubc0f \ub370\uc774\ud130 \uc5f0\uc18d \uc870\ud68c \uad00\ub9ac  </li> <li> <p>Socket : WebSocket \uc5f0\uacb0 \ubc0f \uc218\uba85 \uad00\ub9ac, \ub370\uc774\ud130 \uc218\uc2e0 \ud6c4 asyncio.Queue\uc5d0 \uc804\ub2ec  </p> </li> <li> <p>API : </p> <ul> <li>\uae30\ubcf8\uc801\uc778 REST API Http \uc694\uccad \ubc0f \uc751\ub2f5 \uad00\ub9ac  </li> <li>Queue\ub97c \uc18c\ube44\ud558\uba70 ping-pong, login \ubc0f \ub370\uc774\ud130 \ub514\ucf54\ub529 \uc218\ud589  </li> <li>\uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \uc8fc\uc81c\ubcc4 \uc2a4\ud2b8\ub9bc/\ucf5c\ubc31/\uad6c\ub3c5 \uad00\ub9ac  </li> </ul> </li> <li> <p>Bot : API \uae30\ub2a5\uc744 \ud65c\uc6a9\ud558\uc5ec \uc804\ub7b5\uc744 \uc218\ud589\ud558\ub3c4\ub85d \uc0ac\uc6a9\uc790\uac00 \uad6c\ud604 </p> </li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License \u00a9 Contributors</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<ul> <li>\ubcf8 \ud504\ub85c\uc81d\ud2b8\ub294 \ud0a4\uc6c0\uc99d\uad8c \uacf5\uc2dd \ud504\ub85c\uc81d\ud2b8\uac00 \uc544\ub2d9\ub2c8\ub2e4.</li> <li>\uc2e4\uc81c \uc6b4\uc6a9 \uc804 \ubaa8\uc758 \ud14c\uc2a4\ud2b8 \ud658\uacbd\uc5d0\uc11c \ucda9\ubd84\ud788 \uac80\uc99d \ubc14\ub78d\ub2c8\ub2e4.</li> <li>\ubc1c\uc0dd\ud55c \uc5b4\ub5a0\ud55c \uc190\uc2e4\uc5d0 \ub300\ud558\uc5ec\ub3c4 \ubcf8 \ud504\ub85c\uc81d\ud2b8\uc758 \uac1c\ubc1c\uc790\ub294 \ucc45\uc784\uc774 \uc5c6\uc74c\uc744 \uc54c\ub9bd\ub2c8\ub2e4.</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#kiwoom","title":"kiwoom","text":""},{"location":"api/#kiwoom.Bot","title":"Bot","text":"<p>Kiwoom REST API\ub97c \uc774\uc6a9\ud574 \uc804\ub7b5\uc744 \uc2e4\ud589\ud558\ub294 \ucd5c\uc0c1\uc704 \ud074\ub798\uc2a4\uc785\ub2c8\ub2e4.</p> <p>\uc0ac\uc6a9\uc790\uac00 API \uc138\ubd80 \ub3d9\uc791\uc744 \uc54c\uc9c0 \ubabb\ud574\ub3c4 \uc804\ub7b5 \uc218\ud589\uc5d0 \uc9d1\uc911\ud560 \uc218 \uc788\ub3c4\ub85d \ud569\ub2c8\ub2e4.</p> Source code in <code>kiwoom/bot.py</code> <pre><code>class Bot:\n    \"\"\"\n    Kiwoom REST API\ub97c \uc774\uc6a9\ud574 \uc804\ub7b5\uc744 \uc2e4\ud589\ud558\ub294 \ucd5c\uc0c1\uc704 \ud074\ub798\uc2a4\uc785\ub2c8\ub2e4.\n\n    \uc0ac\uc6a9\uc790\uac00 API \uc138\ubd80 \ub3d9\uc791\uc744 \uc54c\uc9c0 \ubabb\ud574\ub3c4 \uc804\ub7b5 \uc218\ud589\uc5d0 \uc9d1\uc911\ud560 \uc218 \uc788\ub3c4\ub85d \ud569\ub2c8\ub2e4.\n    \"\"\"\n\n    def __init__(self, host: str, appkey: str, secretkey: str, api: API | None = None):\n        \"\"\"\n        Bot \ud074\ub798\uc2a4 \uc778\uc2a4\ud134\uc2a4\ub97c \ucd08\uae30\ud654\ud569\ub2c8\ub2e4.\n\n        Args:\n            host (str): \uc2e4\uc11c\ubc84 / \ubaa8\uc758\uc11c\ubc84 \ub3c4\uba54\uc778\n            appkey (str): \ud30c\uc77c\uacbd\ub85c / \uc571\ud0a4\n            secretkey (str): \ud30c\uc77c\uacbd\ub85c / \uc2dc\ud06c\ub9bf\ud0a4\n            api (API, optional): API\ub97c \ubcc4\ub3c4\ub85c \uad6c\ud604\ud588\ub2e4\uba74 \uc778\uc2a4\ud134\uc2a4 \uc804\ub2ec\uac00\ub2a5\n        \"\"\"\n        self.api = api if api else API(host, appkey, secretkey)\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"\n        async with \uad6c\ubb38\uc5d0\uc11c Bot \uc778\uc2a4\ud134\uc2a4\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n        Returns:\n            Bot: self\n        \"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        \"\"\"\n        async with \uad6c\ubb38\uc744 \uc885\ub8cc\ud560 \ub54c \uc5f0\uacb0\uc744 \ud574\uc81c\ud558\uace0 \ub9ac\uc18c\uc2a4\ub97c \uc815\ub9ac\ud569\ub2c8\ub2e4.\n\n        Args:\n            exc_type (_type_): exception type\n            exc_value (_type_): exception value\n            traceback (_type_): traceback\n        \"\"\"\n        with contextlib.suppress(EXCEPTIONS_TO_SUPPRESS):\n            await asyncio.shield(self.close())\n\n    def debug(self, debugging: bool = True) -&gt; None:\n        \"\"\"\n        \ub514\ubc84\uae45 \ubaa8\ub4dc \ud65c\uc131\ud654 / \ube44\ud65c\uc131\ud654.\n        \ub514\ubc84\uae45 \ubaa8\ub4dc\uc5d0\uc11c\ub294 Http \uc694\uccad\uacfc \uc751\ub2f5\uc774 \ucd9c\ub825\ub429\ub2c8\ub2e4.\n\n        Args:\n            debugging (bool): \ub514\ubc84\uae45 \ubaa8\ub4dc \ud65c\uc131\ud654 \uc5ec\ubd80\n        \"\"\"\n        self.api.debugging = debugging\n\n    def token(self) -&gt; str:\n        \"\"\"\n        \uc5f0\uacb0\uc774 \ub418\uc5c8\ub2e4\uba74, \ud0a4\uc6c0 REST API \ud1a0\ud070\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n        Returns:\n            str: token\n        \"\"\"\n        return self.api.token()\n\n    async def connect(self):\n        \"\"\"\n        \ud0a4\uc6c0 REST API HTTP \uc11c\ubc84 \ubc0f Websocket \uc11c\ubc84\uc5d0 \uc811\uc18d\ud569\ub2c8\ub2e4.\n        \"\"\"\n        await self.api.connect()\n        await asyncio.sleep(1)\n\n    async def close(self):\n        \"\"\"\n        \ud0a4\uc6c0 REST API HTTP \uc11c\ubc84 \ubc0f Websocket \uc11c\ubc84 \uc5f0\uacb0\uc744 \ud574\uc81c\ud569\ub2c8\ub2e4.\n        \"\"\"\n        await asyncio.shield(self.api.close())\n\n    async def stock_list(self, market: str, ats: bool = True) -&gt; list[str]:\n        \"\"\"\n        \uc8fc\uc5b4\uc9c4 market code\uc5d0 \ud574\ub2f9\ud558\ub294 \uc8fc\uc2dd \uc885\ubaa9\ucf54\ub4dc \ubaa9\ub85d\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n        Args:\n            market (str): {\n                'KOSPI': '0', 'KOSDAQ': '10', 'ELW': '3',\n                '\ubba4\ucd94\uc5bc\ud380\ub4dc': '4', '\uc2e0\uc8fc\uc778\uc218\uad8c': '5', '\ub9ac\uce20': '6',\n                'ETF': '8', '\ud558\uc774\uc77c\ub4dc\ud380\ub4dc': '9', 'K-OTC': '30',\n                'KONEX': '50', 'ETN': '60', 'NXT': 'NXT'}\n            ats (bool, optional): \ub300\uccb4\uac70\ub798\uc18c \ubc18\uc601\ud55c \ud1b5\ud569\ucf54\ub4dc \uc5ec\ubd80 (ex. '005930_AL')\n\n        Returns:\n            list[str]: \uc885\ubaa9\ucf54\ub4dc \ub9ac\uc2a4\ud2b8\n        \"\"\"\n\n        # Add NXT market\n        if market == \"NXT\":\n            kospi = await self.stock_list(\"0\")\n            kosdaq = await self.stock_list(\"10\")\n            codes = [c for c in kospi + kosdaq if \"AL\" in c]\n            return sorted(codes)\n\n        data = await self.api.stock_list(market)\n        codes = proc.stock_list(data, ats)\n        return codes\n\n    async def candle(\n        self,\n        code: str,\n        period: str,\n        ctype: str,\n        start: str = None,\n        end: str = None,\n    ) -&gt; DataFrame:\n        \"\"\"\n        \uc8fc\uc5b4\uc9c4 \ucf54\ub4dc, \uae30\uac04, \uc885\ubaa9/\uc5c5\uc885 \uc720\ud615\uc5d0 \ud574\ub2f9\ud558\ub294 \uce94\ub4e4\ucc28\ud2b8 \ub370\uc774\ud130\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n        Args:\n            code (str): \uc885\ubaa9\ucf54\ub4dc / \uc5c5\uc885\ucf54\ub4dc\n            period (str): \uce94\ub4e4 \uae30\uac04\uc720\ud615 {\"tick\", \"min\", \"day\"}\n            ctype (str): \uc885\ubaa9 / \uc5c5\uc885\uc720\ud615 {\"stock\", \"sector\"}\n            start (str, optional): \uc2dc\uc791\uc77c\uc790 in YYYYMMDD format\n            end (str, optional): \uc885\ub8cc\uc77c\uc790 in YYYYMMDD format\n\n        Returns:\n            DataFrame: Pandas \uce94\ub4e4\ucc28\ud2b8 \ub370\uc774\ud130\ud504\ub808\uc784\n        \"\"\"\n        data = await self.api.candle(code, period, ctype, start, end)\n        df = proc.candle.process(data, code, period, ctype, start, end)\n        return df\n\n    async def trade(self, start: str, end: str = \"\") -&gt; DataFrame:\n        \"\"\"\n        \uc8fc\uc5b4\uc9c4 \uc2dc\uc791\uc77c\uc790\uc640 \uc885\ub8cc\uc77c\uc790\uc5d0 \ud574\ub2f9\ud558\ub294 \uccb4\uacb0\ub0b4\uc5ed\uc744\n        \ud0a4\uc6c0\uc99d\uad8c '0343' \uacc4\uc88c \uccb4\uacb0\ub0b4\uc5ed \ud654\uba74\uacfc \ub3d9\uc77c\ud55c \uad6c\uc131\uc73c\ub85c \ubc18\ud658\ud569\ub2c8\ub2e4.\n        \ub370\uc774\ud130 \uc870\ud68c \uc81c\ud55c\uc73c\ub85c \ucd5c\uadfc 2\uac1c\uc6d4 \ub370\uc774\ud130\ub9cc \uc870\ud68c\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n        \uccb4\uacb0\ub0b4\uc5ed \ub370\uc774\ud130\ub294 [\uc54c\ud30c\ub178\ud2b8](http://alphanote.io)\ub97c \ud1b5\ud574\n        \uac04\ud3b8\ud558\uac8c \uc9c4\uc785/\uccad\uc0b0 \uc2dc\uac01\ud654 \ubc0f \uc131\uacfc \uc9c0\ud45c\ub4e4\uc744 \ud655\uc778\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n        Args:\n            start (str): \uc2dc\uc791\uc77c\uc790 in YYYYMMDD format\n            end (str, optional): \uc885\ub8cc\uc77c\uc790 in YYYYMMDD format\n\n        Returns:\n            DataFrame: \ud0a4\uc6c0\uc99d\uad8c '0343' \ud654\uba74 'Excel \ub0b4\ubcf4\ub0b4\uae30' \ud615\uc2dd\n        \"\"\"\n        data = await self.api.trade(start, end)\n        df = proc.trade.process(data)\n        return df\n\n    async def run(self):\n        \"\"\"\n        \uc804\ub7b5 \ub85c\uc9c1\uc744 \uad6c\ud604\ud558\uace0 \uc2e4\ud589\ud569\ub2c8\ub2e4.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/#kiwoom.Bot.api","title":"api  <code>instance-attribute</code>","text":"<pre><code>api = api if api else API(host, appkey, secretkey)\n</code></pre>"},{"location":"api/#kiwoom.Bot.debug","title":"debug","text":"<pre><code>debug(debugging=True)\n</code></pre> <p>\ub514\ubc84\uae45 \ubaa8\ub4dc \ud65c\uc131\ud654 / \ube44\ud65c\uc131\ud654. \ub514\ubc84\uae45 \ubaa8\ub4dc\uc5d0\uc11c\ub294 Http \uc694\uccad\uacfc \uc751\ub2f5\uc774 \ucd9c\ub825\ub429\ub2c8\ub2e4.</p> <p>Parameters:</p> Name Type Description Default <code>debugging</code> <code>bool</code> <p>\ub514\ubc84\uae45 \ubaa8\ub4dc \ud65c\uc131\ud654 \uc5ec\ubd80</p> <code>True</code> Source code in <code>kiwoom/bot.py</code> <pre><code>def debug(self, debugging: bool = True) -&gt; None:\n    \"\"\"\n    \ub514\ubc84\uae45 \ubaa8\ub4dc \ud65c\uc131\ud654 / \ube44\ud65c\uc131\ud654.\n    \ub514\ubc84\uae45 \ubaa8\ub4dc\uc5d0\uc11c\ub294 Http \uc694\uccad\uacfc \uc751\ub2f5\uc774 \ucd9c\ub825\ub429\ub2c8\ub2e4.\n\n    Args:\n        debugging (bool): \ub514\ubc84\uae45 \ubaa8\ub4dc \ud65c\uc131\ud654 \uc5ec\ubd80\n    \"\"\"\n    self.api.debugging = debugging\n</code></pre>"},{"location":"api/#kiwoom.Bot.token","title":"token","text":"<pre><code>token()\n</code></pre> <p>\uc5f0\uacb0\uc774 \ub418\uc5c8\ub2e4\uba74, \ud0a4\uc6c0 REST API \ud1a0\ud070\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>token</p> Source code in <code>kiwoom/bot.py</code> <pre><code>def token(self) -&gt; str:\n    \"\"\"\n    \uc5f0\uacb0\uc774 \ub418\uc5c8\ub2e4\uba74, \ud0a4\uc6c0 REST API \ud1a0\ud070\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n    Returns:\n        str: token\n    \"\"\"\n    return self.api.token()\n</code></pre>"},{"location":"api/#kiwoom.Bot.connect","title":"connect  <code>async</code>","text":"<pre><code>connect()\n</code></pre> <p>\ud0a4\uc6c0 REST API HTTP \uc11c\ubc84 \ubc0f Websocket \uc11c\ubc84\uc5d0 \uc811\uc18d\ud569\ub2c8\ub2e4.</p> Source code in <code>kiwoom/bot.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    \ud0a4\uc6c0 REST API HTTP \uc11c\ubc84 \ubc0f Websocket \uc11c\ubc84\uc5d0 \uc811\uc18d\ud569\ub2c8\ub2e4.\n    \"\"\"\n    await self.api.connect()\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"api/#kiwoom.Bot.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>\ud0a4\uc6c0 REST API HTTP \uc11c\ubc84 \ubc0f Websocket \uc11c\ubc84 \uc5f0\uacb0\uc744 \ud574\uc81c\ud569\ub2c8\ub2e4.</p> Source code in <code>kiwoom/bot.py</code> <pre><code>async def close(self):\n    \"\"\"\n    \ud0a4\uc6c0 REST API HTTP \uc11c\ubc84 \ubc0f Websocket \uc11c\ubc84 \uc5f0\uacb0\uc744 \ud574\uc81c\ud569\ub2c8\ub2e4.\n    \"\"\"\n    await asyncio.shield(self.api.close())\n</code></pre>"},{"location":"api/#kiwoom.Bot.stock_list","title":"stock_list  <code>async</code>","text":"<pre><code>stock_list(market, ats=True)\n</code></pre> <p>\uc8fc\uc5b4\uc9c4 market code\uc5d0 \ud574\ub2f9\ud558\ub294 \uc8fc\uc2dd \uc885\ubaa9\ucf54\ub4dc \ubaa9\ub85d\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>{ 'KOSPI': '0', 'KOSDAQ': '10', 'ELW': '3', '\ubba4\ucd94\uc5bc\ud380\ub4dc': '4', '\uc2e0\uc8fc\uc778\uc218\uad8c': '5', '\ub9ac\uce20': '6', 'ETF': '8', '\ud558\uc774\uc77c\ub4dc\ud380\ub4dc': '9', 'K-OTC': '30', 'KONEX': '50', 'ETN': '60', 'NXT': 'NXT'}</p> required <code>ats</code> <code>bool</code> <p>\ub300\uccb4\uac70\ub798\uc18c \ubc18\uc601\ud55c \ud1b5\ud569\ucf54\ub4dc \uc5ec\ubd80 (ex. '005930_AL')</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: \uc885\ubaa9\ucf54\ub4dc \ub9ac\uc2a4\ud2b8</p> Source code in <code>kiwoom/bot.py</code> <pre><code>async def stock_list(self, market: str, ats: bool = True) -&gt; list[str]:\n    \"\"\"\n    \uc8fc\uc5b4\uc9c4 market code\uc5d0 \ud574\ub2f9\ud558\ub294 \uc8fc\uc2dd \uc885\ubaa9\ucf54\ub4dc \ubaa9\ub85d\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n    Args:\n        market (str): {\n            'KOSPI': '0', 'KOSDAQ': '10', 'ELW': '3',\n            '\ubba4\ucd94\uc5bc\ud380\ub4dc': '4', '\uc2e0\uc8fc\uc778\uc218\uad8c': '5', '\ub9ac\uce20': '6',\n            'ETF': '8', '\ud558\uc774\uc77c\ub4dc\ud380\ub4dc': '9', 'K-OTC': '30',\n            'KONEX': '50', 'ETN': '60', 'NXT': 'NXT'}\n        ats (bool, optional): \ub300\uccb4\uac70\ub798\uc18c \ubc18\uc601\ud55c \ud1b5\ud569\ucf54\ub4dc \uc5ec\ubd80 (ex. '005930_AL')\n\n    Returns:\n        list[str]: \uc885\ubaa9\ucf54\ub4dc \ub9ac\uc2a4\ud2b8\n    \"\"\"\n\n    # Add NXT market\n    if market == \"NXT\":\n        kospi = await self.stock_list(\"0\")\n        kosdaq = await self.stock_list(\"10\")\n        codes = [c for c in kospi + kosdaq if \"AL\" in c]\n        return sorted(codes)\n\n    data = await self.api.stock_list(market)\n    codes = proc.stock_list(data, ats)\n    return codes\n</code></pre>"},{"location":"api/#kiwoom.Bot.candle","title":"candle  <code>async</code>","text":"<pre><code>candle(code, period, ctype, start=None, end=None)\n</code></pre> <p>\uc8fc\uc5b4\uc9c4 \ucf54\ub4dc, \uae30\uac04, \uc885\ubaa9/\uc5c5\uc885 \uc720\ud615\uc5d0 \ud574\ub2f9\ud558\ub294 \uce94\ub4e4\ucc28\ud2b8 \ub370\uc774\ud130\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>\uc885\ubaa9\ucf54\ub4dc / \uc5c5\uc885\ucf54\ub4dc</p> required <code>period</code> <code>str</code> <p>\uce94\ub4e4 \uae30\uac04\uc720\ud615 {\"tick\", \"min\", \"day\"}</p> required <code>ctype</code> <code>str</code> <p>\uc885\ubaa9 / \uc5c5\uc885\uc720\ud615 {\"stock\", \"sector\"}</p> required <code>start</code> <code>str</code> <p>\uc2dc\uc791\uc77c\uc790 in YYYYMMDD format</p> <code>None</code> <code>end</code> <code>str</code> <p>\uc885\ub8cc\uc77c\uc790 in YYYYMMDD format</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>Pandas \uce94\ub4e4\ucc28\ud2b8 \ub370\uc774\ud130\ud504\ub808\uc784</p> Source code in <code>kiwoom/bot.py</code> <pre><code>async def candle(\n    self,\n    code: str,\n    period: str,\n    ctype: str,\n    start: str = None,\n    end: str = None,\n) -&gt; DataFrame:\n    \"\"\"\n    \uc8fc\uc5b4\uc9c4 \ucf54\ub4dc, \uae30\uac04, \uc885\ubaa9/\uc5c5\uc885 \uc720\ud615\uc5d0 \ud574\ub2f9\ud558\ub294 \uce94\ub4e4\ucc28\ud2b8 \ub370\uc774\ud130\ub97c \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n    Args:\n        code (str): \uc885\ubaa9\ucf54\ub4dc / \uc5c5\uc885\ucf54\ub4dc\n        period (str): \uce94\ub4e4 \uae30\uac04\uc720\ud615 {\"tick\", \"min\", \"day\"}\n        ctype (str): \uc885\ubaa9 / \uc5c5\uc885\uc720\ud615 {\"stock\", \"sector\"}\n        start (str, optional): \uc2dc\uc791\uc77c\uc790 in YYYYMMDD format\n        end (str, optional): \uc885\ub8cc\uc77c\uc790 in YYYYMMDD format\n\n    Returns:\n        DataFrame: Pandas \uce94\ub4e4\ucc28\ud2b8 \ub370\uc774\ud130\ud504\ub808\uc784\n    \"\"\"\n    data = await self.api.candle(code, period, ctype, start, end)\n    df = proc.candle.process(data, code, period, ctype, start, end)\n    return df\n</code></pre>"},{"location":"api/#kiwoom.Bot.trade","title":"trade  <code>async</code>","text":"<pre><code>trade(start, end='')\n</code></pre> <p>\uc8fc\uc5b4\uc9c4 \uc2dc\uc791\uc77c\uc790\uc640 \uc885\ub8cc\uc77c\uc790\uc5d0 \ud574\ub2f9\ud558\ub294 \uccb4\uacb0\ub0b4\uc5ed\uc744 \ud0a4\uc6c0\uc99d\uad8c '0343' \uacc4\uc88c \uccb4\uacb0\ub0b4\uc5ed \ud654\uba74\uacfc \ub3d9\uc77c\ud55c \uad6c\uc131\uc73c\ub85c \ubc18\ud658\ud569\ub2c8\ub2e4. \ub370\uc774\ud130 \uc870\ud68c \uc81c\ud55c\uc73c\ub85c \ucd5c\uadfc 2\uac1c\uc6d4 \ub370\uc774\ud130\ub9cc \uc870\ud68c\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.</p> <p>\uccb4\uacb0\ub0b4\uc5ed \ub370\uc774\ud130\ub294 \uc54c\ud30c\ub178\ud2b8\ub97c \ud1b5\ud574 \uac04\ud3b8\ud558\uac8c \uc9c4\uc785/\uccad\uc0b0 \uc2dc\uac01\ud654 \ubc0f \uc131\uacfc \uc9c0\ud45c\ub4e4\uc744 \ud655\uc778\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>\uc2dc\uc791\uc77c\uc790 in YYYYMMDD format</p> required <code>end</code> <code>str</code> <p>\uc885\ub8cc\uc77c\uc790 in YYYYMMDD format</p> <code>''</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>\ud0a4\uc6c0\uc99d\uad8c '0343' \ud654\uba74 'Excel \ub0b4\ubcf4\ub0b4\uae30' \ud615\uc2dd</p> Source code in <code>kiwoom/bot.py</code> <pre><code>async def trade(self, start: str, end: str = \"\") -&gt; DataFrame:\n    \"\"\"\n    \uc8fc\uc5b4\uc9c4 \uc2dc\uc791\uc77c\uc790\uc640 \uc885\ub8cc\uc77c\uc790\uc5d0 \ud574\ub2f9\ud558\ub294 \uccb4\uacb0\ub0b4\uc5ed\uc744\n    \ud0a4\uc6c0\uc99d\uad8c '0343' \uacc4\uc88c \uccb4\uacb0\ub0b4\uc5ed \ud654\uba74\uacfc \ub3d9\uc77c\ud55c \uad6c\uc131\uc73c\ub85c \ubc18\ud658\ud569\ub2c8\ub2e4.\n    \ub370\uc774\ud130 \uc870\ud68c \uc81c\ud55c\uc73c\ub85c \ucd5c\uadfc 2\uac1c\uc6d4 \ub370\uc774\ud130\ub9cc \uc870\ud68c\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n    \uccb4\uacb0\ub0b4\uc5ed \ub370\uc774\ud130\ub294 [\uc54c\ud30c\ub178\ud2b8](http://alphanote.io)\ub97c \ud1b5\ud574\n    \uac04\ud3b8\ud558\uac8c \uc9c4\uc785/\uccad\uc0b0 \uc2dc\uac01\ud654 \ubc0f \uc131\uacfc \uc9c0\ud45c\ub4e4\uc744 \ud655\uc778\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n    Args:\n        start (str): \uc2dc\uc791\uc77c\uc790 in YYYYMMDD format\n        end (str, optional): \uc885\ub8cc\uc77c\uc790 in YYYYMMDD format\n\n    Returns:\n        DataFrame: \ud0a4\uc6c0\uc99d\uad8c '0343' \ud654\uba74 'Excel \ub0b4\ubcf4\ub0b4\uae30' \ud615\uc2dd\n    \"\"\"\n    data = await self.api.trade(start, end)\n    df = proc.trade.process(data)\n    return df\n</code></pre>"},{"location":"api/#kiwoom.Bot.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>\uc804\ub7b5 \ub85c\uc9c1\uc744 \uad6c\ud604\ud558\uace0 \uc2e4\ud589\ud569\ub2c8\ub2e4.</p> Source code in <code>kiwoom/bot.py</code> <pre><code>async def run(self):\n    \"\"\"\n    \uc804\ub7b5 \ub85c\uc9c1\uc744 \uad6c\ud604\ud558\uace0 \uc2e4\ud589\ud569\ub2c8\ub2e4.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#kiwoom.API","title":"API","text":"<p>               Bases: <code>Client</code></p> <p>Kiwoom REST API \uc11c\ubc84\uc640 \uc9c1\uc811 \uc694\uccad\uacfc \uc751\ub2f5\uc744 \uc8fc\uace0\ubc1b\ub294 \ud074\ub798\uc2a4\uc785\ub2c8\ub2e4.</p> <p>\ub370\uc774\ud130 \uc870\ud68c, \uc8fc\ubb38 \uc694\uccad \ub4f1 \uc800\uc218\uc900 \ud1b5\uc2e0\uc744 \ub2f4\ub2f9\ud558\uba70, \uc9c1\uc811 API \uc2a4\ud399\uc744 \uad6c\ud604\ud558\uc5ec \ud65c\uc6a9\ud569\ub2c8\ub2e4.</p> Source code in <code>kiwoom/api.py</code> <pre><code>class API(Client):\n    \"\"\"\n    Kiwoom REST API \uc11c\ubc84\uc640 \uc9c1\uc811 \uc694\uccad\uacfc \uc751\ub2f5\uc744 \uc8fc\uace0\ubc1b\ub294 \ud074\ub798\uc2a4\uc785\ub2c8\ub2e4.\n\n    \ub370\uc774\ud130 \uc870\ud68c, \uc8fc\ubb38 \uc694\uccad \ub4f1 \uc800\uc218\uc900 \ud1b5\uc2e0\uc744 \ub2f4\ub2f9\ud558\uba70,\n    \uc9c1\uc811 API \uc2a4\ud399\uc744 \uad6c\ud604\ud558\uc5ec \ud65c\uc6a9\ud569\ub2c8\ub2e4.\n    \"\"\"\n\n    def __init__(self, host: str, appkey: str, secretkey: str):\n        \"\"\"\n        API \ud074\ub798\uc2a4 \uc778\uc2a4\ud134\uc2a4\ub97c \ucd08\uae30\ud654\ud569\ub2c8\ub2e4.\n\n        Args:\n            host (str): \uc2e4\uc11c\ubc84 / \ubaa8\uc758\uc11c\ubc84 \ub3c4\uba54\uc778\n            appkey (str): \ud30c\uc77c\uacbd\ub85c / \uc571\ud0a4\n            secretkey (str): \ud30c\uc77c\uacbd\ub85c / \uc2dc\ud06c\ub9bf\ud0a4\n\n        Raises:\n            ValueError: \uc720\ud6a8\ud558\uc9c0 \uc54a\uc740 \ub3c4\uba54\uc778\n        \"\"\"\n        match host:\n            case config.REAL:\n                wss_url = Socket.REAL + Socket.ENDPOINT\n            case config.MOCK:\n                wss_url = Socket.MOCK + Socket.ENDPOINT\n            case _:\n                raise ValueError(f\"Invalid host: {self.host}\")\n\n        super().__init__(host, appkey, secretkey)\n        self.queue = asyncio.Queue(maxsize=WEBSOCKET_QUEUE_MAX_SIZE)\n        self.socket = Socket(url=wss_url, queue=self.queue)\n\n        self._state = State.CLOSED\n        self._state_lock = asyncio.Lock()\n        self._recv_task: asyncio.Task | None = None\n        self._stop_event = asyncio.Event()\n        self._stop_event.set()\n\n        self._sem = asyncio.Semaphore(config.http.WEBSOCKET_MAX_CONCURRENCY)\n        async_print = wrap_sync_callback(self._sem, lambda msg: print(msg))\n        self._callbacks = defaultdict(lambda: async_print)\n        self._add_default_callback_on_real_data()\n\n    async def connect(self):\n        \"\"\"\n        \ud0a4\uc6c0 REST API HTTP \uc11c\ubc84\uc640 Websocket \uc11c\ubc84\uc5d0 \uc811\uc18d\ud558\uace0 \ud1a0\ud070\uc744 \ubc1c\uae09\ubc1b\uc2b5\ub2c8\ub2e4.\n\n        Raises:\n            RuntimeError: \ud1a0\ud070\uc744 \ubc1c\uae09\ubc1b\uc9c0 \ubabb\ud55c \uacbd\uc6b0\n            Exception: \uc608\uc0c1\ud558\uc9c0 \ubabb\ud55c \uc5d0\ub7ec\n        \"\"\"\n        async with self._state_lock:\n            if self._state in (State.CONNECTED, State.CONNECTING):\n                return\n\n            self._state = State.CONNECTING\n            try:\n                # Cancel existing task\n                self._stop_event.set()\n                await cancel(self._recv_task)\n\n                # Connect http server\n                await super().connect(self._appkey, self._secretkey)\n                if not (token := self.token()):\n                    raise RuntimeError(\"Not connected: token is not available.\")\n\n                # Connect websocket server\n                await self.socket.connect(self._session, token)\n\n                # Run websocket receiving task\n                self._stop_event.clear()\n                self._recv_task = asyncio.create_task(self._on_receive_websocket(), name=\"dequeue\")\n                self._state = State.CONNECTED\n\n            except Exception as err:\n                self._state = State.CLOSED\n                with contextlib.suppress(Exception):\n                    await self.socket.close()\n                with contextlib.suppress(Exception):\n                    await super().close()\n                raise Exception from err\n\n    async def close(self):\n        \"\"\"\n        \ud0a4\uc6c0 REST API \uc11c\ubc84\uc640 \uc5f0\uacb0\uc744 \ud574\uc81c\ud558\uace0 \ub9ac\uc18c\uc2a4\ub97c \uc815\ub9ac\ud569\ub2c8\ub2e4.\n        \"\"\"\n        async with self._state_lock:\n            if self._state in (State.CLOSED, State.CLOSING):\n                return\n\n            self._state = State.CLOSING\n            try:\n                # Cancel existing task\n                self._stop_event.set()\n                with contextlib.suppress(EXCEPTIONS_TO_SUPPRESS):\n                    await asyncio.shield(cancel(self._recv_task))\n                self._recv_task = None\n\n                # Close websocket server\n                with contextlib.suppress(EXCEPTIONS_TO_SUPPRESS):\n                    await asyncio.shield(self.socket.close())\n                # Close http server\n                with contextlib.suppress(EXCEPTIONS_TO_SUPPRESS):\n                    await asyncio.shield(super().close())\n\n            finally:\n                self._state = State.CLOSED\n\n    async def stock_list(self, market: str) -&gt; dict:\n        \"\"\"\n        \uc8fc\uc5b4\uc9c4 market \ucf54\ub4dc\uc5d0 \ub300\ud574 'ka10099' API \uc694\uccad\uc744 \ud558\uace0 \uc751\ub2f5\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n        Args:\n            market (str): \uc870\ud68c\ud560 \uc8fc\uc2dd \uc2dc\uc7a5\ucf54\ub4dc\n\n        Raises:\n            ValueError: \uc885\ubaa9\ucf54\ub4dc \ubaa9\ub85d\uc774 \uc5c6\uc744 \uacbd\uc6b0\n\n        Returns:\n            dict: \uc885\ubaa9\ucf54\ub4dc \ubaa9\ub85d\uc744 \ud3ec\ud568\ud558\ub294 \uc751\ub2f5\n        \"\"\"\n        endpoint = \"/api/dostk/stkinfo\"\n        api_id = \"ka10099\"\n\n        res = await self.request(endpoint, api_id, data={\"mrkt_tp\": market})\n        body = res.json()\n        if not body[\"list\"] or len(body[\"list\"]) &lt;= 1:\n            raise ValueError(f\"Stock list is not available for market code, {market}.\")\n        return body\n\n    async def candle(\n        self,\n        code: str,\n        period: str,\n        ctype: str,\n        start: str = None,\n        end: str = None,\n    ) -&gt; dict:\n        \"\"\"\n        \uc8fc\uc5b4\uc9c4 \ucf54\ub4dc, \uae30\uac04, \uc885\ubaa9/\uc5c5\uc885 \uc720\ud615\uc5d0 \ud574\ub2f9\ud558\ub294 API \uc694\uccad\uc744 \ud558\uace0 \uc751\ub2f5\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n        \"stock\": {\"tick\": \"ka10079\", \"min\": \"ka10080\", \"day\": \"ka10081\"}\n\n        \"sector\": {\"tick\": \"ka20004\", \"min\": \"ka20005\", \"day\": \"ka20006\"}\n\n        Args:\n            code (str): \uc885\ubaa9\ucf54\ub4dc / \uc5c5\uc885\ucf54\ub4dc\n            period (str): \uce94\ub4e4 \uae30\uac04\uc720\ud615, {\"tick\", \"min\", \"day\"}.\n            ctype (str): \uc885\ubaa9 / \uc5c5\uc885 \uc720\ud615, {\"stock\", \"sector\"}.\n            start (str, optional): \uc2dc\uc791\uc77c\uc790 in YYYYMMDD format.\n            end (str, optional): \uc885\ub8cc\uc77c\uc790 in YYYYMMDD format.\n\n        Raises:\n            ValueError: \uc720\ud6a8\ud558\uc9c0 \uc54a\uc740 'ctype' \ub610\ub294 'period'\n\n        Returns:\n            dict: \uce94\ub4e4 \ub370\uc774\ud130\ub97c \ud3ec\ud568\ud558\ub294 json \uc751\ub2f5\n        \"\"\"\n\n        ctype = ctype.lower()\n        endpoint = \"/api/dostk/chart\"\n        api_id = PERIOD_TO_API_ID[ctype][period]\n        data = dict(PERIOD_TO_DATA[ctype][period])\n        match ctype:\n            case \"stock\":\n                data[\"stk_cd\"] = code\n            case \"sector\":\n                data[\"inds_cd\"] = code\n            case _:\n                raise ValueError(f\"'ctype' must be one of [stock, sector], not {ctype=}.\")\n        if period == \"day\":\n            end = end if end else datetime.now().strftime(\"%Y%m%d\")\n            data[\"base_dt\"] = end\n\n        ymd: int = len(\"YYYYMMDD\")  # 8 digit compare\n        key: str = PERIOD_TO_BODY_KEY[ctype][period]\n        time: str = PERIOD_TO_TIME_KEY[period]\n\n        def should_continue(body: dict) -&gt; bool:\n            # Validate\n            if not valid(body, period, ctype):\n                return False\n            # Request full data\n            if not start:\n                return True\n            # Condition to continue\n            chart = body[key]\n            earliest = chart[-1][time][:ymd]\n            return start &lt;= earliest\n\n        body = await self.request_until(should_continue, endpoint, api_id, data=data)\n        return body\n\n    async def trade(self, start: str, end: str = \"\") -&gt; list[dict]:\n        \"\"\"\n        \uc8fc\uc5b4\uc9c4 \uc2dc\uc791\uc77c\uc790\uc640 \uc885\ub8cc\uc77c\uc790\uc5d0 \ud574\ub2f9\ud558\ub294 \uccb4\uacb0\ub0b4\uc5ed\uc744\n        \ud0a4\uc6c0\uc99d\uad8c '0343' \uacc4\uc88c \uccb4\uacb0\ub0b4\uc5ed \ud654\uba74\uacfc \ub3d9\uc77c\ud55c \uad6c\uc131\uc73c\ub85c \ubc18\ud658\ud569\ub2c8\ub2e4.\n        \ub370\uc774\ud130 \uc870\ud68c \uc81c\ud55c\uc73c\ub85c \ucd5c\uadfc 2\uac1c\uc6d4 \ub370\uc774\ud130\ub9cc \uc870\ud68c\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n        \uccb4\uacb0\ub0b4\uc5ed \ub370\uc774\ud130\ub294 [\uc54c\ud30c\ub178\ud2b8](http://alphanote.io)\ub97c \ud1b5\ud574\n        \uac04\ud3b8\ud558\uac8c \uc9c4\uc785/\uccad\uc0b0 \uc2dc\uac01\ud654 \ubc0f \uc131\uacfc \uc9c0\ud45c\ub4e4\uc744 \ud655\uc778\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n        Args:\n            start (str): \uc2dc\uc791\uc77c\uc790 in YYYYMMDD format\n            end (str, optional): \uc885\ub8cc\uc77c\uc790 in YYYYMMDD format\n\n        Returns:\n            list[dict]: \uccb4\uacb0\ub0b4\uc5ed \ub370\uc774\ud130\ub97c \ud3ec\ud568\ud558\ub294 json \uc751\ub2f5 \ub9ac\uc2a4\ud2b8\n        \"\"\"\n        endpoint = \"/api/dostk/acnt\"\n        api_id = \"kt00009\"\n        data = {\n            \"ord_dt\": \"\",  # YYYYMMDD (Optional)\n            \"qry_tp\": \"1\",  # \uc804\uccb4/\uccb4\uacb0\n            \"stk_bond_tp\": \"1\",  # \uc804\uccb4/\uc8fc\uc2dd/\ucc44\uad8c\n            \"mrkt_tp\": \"0\",  # \uc804\uccb4/\ucf54\uc2a4\ud53c/\ucf54\uc2a4\ub2e5/OTCBB/ECN\n            \"sell_tp\": \"0\",  # \uc804\uccb4/\ub9e4\ub3c4/\ub9e4\uc218\n            \"dmst_stex_tp\": \"%\",  # \uc804\uccb4/KRX/NXT/SOR\n            # 'stk_cd': '',  # \uc885\ubaa9\ucf54\ub4dc (Optional)\n            # 'fr_ord_no': '',  # \uc2dc\uc791\uc8fc\ubb38\ubc88\ud638 (Optional)\n        }\n\n        today = datetime.today()\n        start = datetime.strptime(start, \"%Y%m%d\")\n        start = max(start, today - timedelta(days=REQUEST_LIMIT_DAYS))\n        end = datetime.strptime(end, \"%Y%m%d\") if end else datetime.today()\n        end = min(end, datetime.today())\n\n        trs = []\n        key = \"acnt_ord_cntr_prst_array\"\n        for bday in bdate_range(start, end):\n            dic = dict(data)\n            dic[\"ord_dt\"] = bday.strftime(\"%Y%m%d\")  # manually set ord_dt\n            body = await self.request_until(lambda x: True, endpoint, api_id, data=dic)\n            if key in body:\n                # Append order date to each record\n                for rec in body[key]:\n                    rec[\"ord_dt\"] = bday.strftime(\"%Y-%m-%d\")\n                trs.extend(body[key])\n        return trs\n\n    def add_callback_on_real_data(self, real_type: str, callback: Callable) -&gt; None:\n        \"\"\"\n        \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \uc218\uc2e0 \uc2dc \ud638\ucd9c\ub420 \ucf5c\ubc31 \ud568\uc218\ub97c \ucd94\uac00\ud569\ub2c8\ub2e4. (trnm\uc774 'REAL'\uc778 \uacbd\uc6b0)\n\n        * callback \ud568\uc218\ub294 \uc11c\ubc84 \uc751\ub2f5 string \uadf8\ub300\ub85c\ub97c \uc778\uc790\ub85c \ubc1b\uc2b5\ub2c8\ub2e4.\n        * real_type\uc744 'PING' \ub610\ub294 'LOGIN'\uc73c\ub85c \uc124\uc815\ud558\uba74 \uae30\ubcf8 \ucf5c\ubc31 \ud568\uc218\ub97c \ub36e\uc5b4\uc501\ub2c8\ub2e4.\n\n        \ucf5c\ubc31 \ud568\uc218\ub294 \ube44\ub3d9\uae30 \ucf5c\ubc31 \ud568\uc218\ub97c \ucd94\uac00\ud558\ub294 \uac83\uc744 \uad8c\uc7a5\ud569\ub2c8\ub2e4.\n        \ube44\ub3d9\uae30 \ubc0f \ub3d9\uae30 \ucf5c\ubc31 \ud568\uc218 \ubaa8\ub450 \ub8e8\ud504\ub97c \ube14\ub85c\ud0b9\ud558\uc9c0 \uc54a\ub3c4\ub85d\n        \ubc31\uadf8\ub77c\uc6b4\ub4dc\uc5d0\uc11c \uc2e4\ud589\ub429\ub2c8\ub2e4. \ub530\ub77c\uc11c \ub370\uc774\ud130 \ucc98\ub9ac \uc644\ub8cc \uc21c\uc11c\uac00 \ubc18\ub4dc\uc2dc\n        \ub370\uc774\ud130 \uc218\uc2e0 \uc21c\uc11c\uc5d0 \ub530\ub77c \uc2e4\ud589\ub418\uc9c0 \uc54a\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n        ex) tick \uccb4\uacb0 \ub370\uc774\ud130 (type 'OB')\uac00 \uc218\uc2e0\ub420 \ub54c\ub9c8\ub2e4 \ub370\uc774\ud130 \ucd9c\ub825\ud558\uae30\n\n            &gt; fn = lambda raw: print(raw)\n\n            &gt; add_callback_on_real_data(real_type='OB', callback=fn)\n\n        Args:\n            real_type (str): \ud0a4\uc6c0 REST API\uc5d0 \uc815\uc758\ub41c \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ud0c0\uc785\n            callback (Callable): raw \uc2a4\ud2b8\ub9c1\uc744 \uc778\uc790\ub85c \ubc1b\ub294 \ucf5c\ubc31 \ud568\uc218\n        \"\"\"\n\n        real_type = real_type.upper()\n        # Asnyc Callback\n        if iscoroutinefunction(callback):\n            self._callbacks[real_type] = wrap_async_callback(self._sem, callback)\n        # Sync Callback\n        else:\n            self._callbacks[real_type] = wrap_sync_callback(self._sem, callback)\n\n    def _add_default_callback_on_real_data(self) -&gt; None:\n        \"\"\"\n        Add default callback functions on real data receive.\n        \"\"\"\n\n        # Ping\n        async def callback_on_ping(msg: dict):\n            await self.socket.send(msg)\n\n        self.add_callback_on_real_data(real_type=\"PING\", callback=callback_on_ping)\n\n        # Login\n        def callback_on_login(msg: dict):\n            if msg.get(\"return_code\") != 0:\n                raise RuntimeError(f\"Login failed with return_code not zero, {msg}.\")\n            print(msg)\n\n        self.add_callback_on_real_data(real_type=\"LOGIN\", callback=callback_on_login)\n\n    async def _on_receive_websocket(self) -&gt; None:\n        \"\"\"\n        Receive websocket data and dispatch to the callback function.\n        Decoder patially checks 'trnm' and 'type' in order to speed up.\n\n        If trnm is \"REAL\", the argument to callback function is RealData instance.\n        Otherwise, the argument to callback function is json dict.\n\n        Raises:\n            Exception: Exception raised by the callback function or decoder\n        \"\"\"\n        decoder = msgspec.json.Decoder(type=RealType)\n        while not self._stop_event.is_set():\n            try:\n                raw: str = await self.queue.get()\n            except asyncio.CancelledError:\n                break\n\n            try:\n                msg = decoder.decode(raw)  # partially decoded for speed up\n                if msg.trnm == \"REAL\":\n                    for data in msg.data:\n                        asyncio.create_task(\n                            self._callbacks[data.type](\n                                RealData(bytes(data.values), data.type, data.name, data.item)\n                            )\n                        )\n                    continue\n\n                dic = orjson.loads(raw)\n                asyncio.create_task(self._callbacks[msg.trnm](dic))\n\n            except Exception as err:\n                raise Exception(\"Failed to handling websocket data.\") from err\n\n            finally:\n                self.queue.task_done()\n\n    async def register_tick(\n        self,\n        grp_no: str,\n        codes: list[str],\n        refresh: str = \"1\",\n    ) -&gt; None:\n        \"\"\"\n        \uc8fc\uc5b4\uc9c4 \uadf8\ub8f9\ubc88\ud638\uc640 \uc885\ubaa9 \ucf54\ub4dc\uc5d0 \ub300\ud574 \uc8fc\uc2dd\uccb4\uacb0 \ub370\uc774\ud130\ub97c \ub4f1\ub85d\ud569\ub2c8\ub2e4. (\ud0c0\uc785 '0B')\n\n        Args:\n            grp_no (str): \uadf8\ub8f9\ubc88\ud638\n            codes (list[str]): \uc885\ubaa9\ucf54\ub4dc \ub9ac\uc2a4\ud2b8\n            refresh (str, optional): \uae30\uc874\ub4f1\ub85d\uc720\uc9c0\uc5ec\ubd80 (\uae30\uc874\uc720\uc9c0:'1', \uc2e0\uaddc\ub4f1\ub85d:'0').\n        \"\"\"\n\n        assert len(codes) &lt;= 100, f\"Max 100 codes per group, got {len(codes)} codes.\"\n        await self.socket.send(\n            {\n                \"trnm\": \"REG\",\n                \"grp_no\": grp_no,\n                \"refresh\": refresh,\n                \"data\": [\n                    {\n                        \"item\": codes,\n                        \"type\": [\"0B\"],\n                    }\n                ],\n            }\n        )\n\n    async def register_hoga(\n        self,\n        grp_no: str,\n        codes: list[str],\n        refresh: str = \"1\",\n    ) -&gt; None:\n        \"\"\"\n        \uc8fc\uc5b4\uc9c4 \uadf8\ub8f9\ubc88\ud638\uc640 \uc885\ubaa9 \ucf54\ub4dc\uc5d0 \ub300\ud574 \uc8fc\uc2dd\ud638\uac00\uc794\ub7c9 \ub370\uc774\ud130\ub97c \ub4f1\ub85d\ud569\ub2c8\ub2e4. (\ud0c0\uc785 '0D')\n\n        Args:\n            grp_no (str): \uadf8\ub8f9\ubc88\ud638\n            codes (list[str]): \uc885\ubaa9\ucf54\ub4dc \ub9ac\uc2a4\ud2b8\n            refresh (str, optional): \uae30\uc874\ub4f1\ub85d\uc720\uc9c0\uc5ec\ubd80 (\uae30\uc874\uc720\uc9c0:'1', \uc2e0\uaddc\ub4f1\ub85d:'0').\n        \"\"\"\n\n        assert len(codes) &lt;= 100, f\"Max 100 codes per group, got {len(codes)} codes.\"\n        await self.socket.send(\n            {\n                \"trnm\": \"REG\",\n                \"grp_no\": grp_no,\n                \"refresh\": refresh,\n                \"data\": [\n                    {\n                        \"item\": codes,\n                        \"type\": [\"0D\"],\n                    }\n                ],\n            }\n        )\n\n    async def remove_register(self, grp_no: str, type: str | list[str]) -&gt; None:\n        \"\"\"\n        \uc8fc\uc5b4\uc9c4 \uadf8\ub8f9\ubc88\ud638\uc640 \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ud0c0\uc785\uc5d0 \ub300\ud574 \ub4f1\ub85d\ub41c \ub370\uc774\ud130\ub97c \uc81c\uac70\ud569\ub2c8\ub2e4.\n\n        Args:\n            grp_no (str): \uadf8\ub8f9\ubc88\ud638\n            type (str | list[str]): \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ud0c0\uc785 ex) '0B', '0D', 'DD'\n        \"\"\"\n        if not grp_no or not type:\n            return\n        if isinstance(type, str):\n            type = [type]\n        await self.socket.send(\n            {\"trnm\": \"REMOVE\", \"grp_no\": grp_no, \"refresh\": \"\", \"data\": [{\"type\": type}]}\n        )\n</code></pre>"},{"location":"api/#kiwoom.API.queue","title":"queue  <code>instance-attribute</code>","text":"<pre><code>queue = Queue(maxsize=WEBSOCKET_QUEUE_MAX_SIZE)\n</code></pre>"},{"location":"api/#kiwoom.API.socket","title":"socket  <code>instance-attribute</code>","text":"<pre><code>socket = Socket(url=wss_url, queue=queue)\n</code></pre>"},{"location":"api/#kiwoom.API.connect","title":"connect  <code>async</code>","text":"<pre><code>connect()\n</code></pre> <p>\ud0a4\uc6c0 REST API HTTP \uc11c\ubc84\uc640 Websocket \uc11c\ubc84\uc5d0 \uc811\uc18d\ud558\uace0 \ud1a0\ud070\uc744 \ubc1c\uae09\ubc1b\uc2b5\ub2c8\ub2e4.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>\ud1a0\ud070\uc744 \ubc1c\uae09\ubc1b\uc9c0 \ubabb\ud55c \uacbd\uc6b0</p> <code>Exception</code> <p>\uc608\uc0c1\ud558\uc9c0 \ubabb\ud55c \uc5d0\ub7ec</p> Source code in <code>kiwoom/api.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    \ud0a4\uc6c0 REST API HTTP \uc11c\ubc84\uc640 Websocket \uc11c\ubc84\uc5d0 \uc811\uc18d\ud558\uace0 \ud1a0\ud070\uc744 \ubc1c\uae09\ubc1b\uc2b5\ub2c8\ub2e4.\n\n    Raises:\n        RuntimeError: \ud1a0\ud070\uc744 \ubc1c\uae09\ubc1b\uc9c0 \ubabb\ud55c \uacbd\uc6b0\n        Exception: \uc608\uc0c1\ud558\uc9c0 \ubabb\ud55c \uc5d0\ub7ec\n    \"\"\"\n    async with self._state_lock:\n        if self._state in (State.CONNECTED, State.CONNECTING):\n            return\n\n        self._state = State.CONNECTING\n        try:\n            # Cancel existing task\n            self._stop_event.set()\n            await cancel(self._recv_task)\n\n            # Connect http server\n            await super().connect(self._appkey, self._secretkey)\n            if not (token := self.token()):\n                raise RuntimeError(\"Not connected: token is not available.\")\n\n            # Connect websocket server\n            await self.socket.connect(self._session, token)\n\n            # Run websocket receiving task\n            self._stop_event.clear()\n            self._recv_task = asyncio.create_task(self._on_receive_websocket(), name=\"dequeue\")\n            self._state = State.CONNECTED\n\n        except Exception as err:\n            self._state = State.CLOSED\n            with contextlib.suppress(Exception):\n                await self.socket.close()\n            with contextlib.suppress(Exception):\n                await super().close()\n            raise Exception from err\n</code></pre>"},{"location":"api/#kiwoom.API.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>\ud0a4\uc6c0 REST API \uc11c\ubc84\uc640 \uc5f0\uacb0\uc744 \ud574\uc81c\ud558\uace0 \ub9ac\uc18c\uc2a4\ub97c \uc815\ub9ac\ud569\ub2c8\ub2e4.</p> Source code in <code>kiwoom/api.py</code> <pre><code>async def close(self):\n    \"\"\"\n    \ud0a4\uc6c0 REST API \uc11c\ubc84\uc640 \uc5f0\uacb0\uc744 \ud574\uc81c\ud558\uace0 \ub9ac\uc18c\uc2a4\ub97c \uc815\ub9ac\ud569\ub2c8\ub2e4.\n    \"\"\"\n    async with self._state_lock:\n        if self._state in (State.CLOSED, State.CLOSING):\n            return\n\n        self._state = State.CLOSING\n        try:\n            # Cancel existing task\n            self._stop_event.set()\n            with contextlib.suppress(EXCEPTIONS_TO_SUPPRESS):\n                await asyncio.shield(cancel(self._recv_task))\n            self._recv_task = None\n\n            # Close websocket server\n            with contextlib.suppress(EXCEPTIONS_TO_SUPPRESS):\n                await asyncio.shield(self.socket.close())\n            # Close http server\n            with contextlib.suppress(EXCEPTIONS_TO_SUPPRESS):\n                await asyncio.shield(super().close())\n\n        finally:\n            self._state = State.CLOSED\n</code></pre>"},{"location":"api/#kiwoom.API.stock_list","title":"stock_list  <code>async</code>","text":"<pre><code>stock_list(market)\n</code></pre> <p>\uc8fc\uc5b4\uc9c4 market \ucf54\ub4dc\uc5d0 \ub300\ud574 'ka10099' API \uc694\uccad\uc744 \ud558\uace0 \uc751\ub2f5\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.</p> <p>Parameters:</p> Name Type Description Default <code>market</code> <code>str</code> <p>\uc870\ud68c\ud560 \uc8fc\uc2dd \uc2dc\uc7a5\ucf54\ub4dc</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>\uc885\ubaa9\ucf54\ub4dc \ubaa9\ub85d\uc774 \uc5c6\uc744 \uacbd\uc6b0</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>\uc885\ubaa9\ucf54\ub4dc \ubaa9\ub85d\uc744 \ud3ec\ud568\ud558\ub294 \uc751\ub2f5</p> Source code in <code>kiwoom/api.py</code> <pre><code>async def stock_list(self, market: str) -&gt; dict:\n    \"\"\"\n    \uc8fc\uc5b4\uc9c4 market \ucf54\ub4dc\uc5d0 \ub300\ud574 'ka10099' API \uc694\uccad\uc744 \ud558\uace0 \uc751\ub2f5\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n    Args:\n        market (str): \uc870\ud68c\ud560 \uc8fc\uc2dd \uc2dc\uc7a5\ucf54\ub4dc\n\n    Raises:\n        ValueError: \uc885\ubaa9\ucf54\ub4dc \ubaa9\ub85d\uc774 \uc5c6\uc744 \uacbd\uc6b0\n\n    Returns:\n        dict: \uc885\ubaa9\ucf54\ub4dc \ubaa9\ub85d\uc744 \ud3ec\ud568\ud558\ub294 \uc751\ub2f5\n    \"\"\"\n    endpoint = \"/api/dostk/stkinfo\"\n    api_id = \"ka10099\"\n\n    res = await self.request(endpoint, api_id, data={\"mrkt_tp\": market})\n    body = res.json()\n    if not body[\"list\"] or len(body[\"list\"]) &lt;= 1:\n        raise ValueError(f\"Stock list is not available for market code, {market}.\")\n    return body\n</code></pre>"},{"location":"api/#kiwoom.API.candle","title":"candle  <code>async</code>","text":"<pre><code>candle(code, period, ctype, start=None, end=None)\n</code></pre> <p>\uc8fc\uc5b4\uc9c4 \ucf54\ub4dc, \uae30\uac04, \uc885\ubaa9/\uc5c5\uc885 \uc720\ud615\uc5d0 \ud574\ub2f9\ud558\ub294 API \uc694\uccad\uc744 \ud558\uace0 \uc751\ub2f5\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.</p> <p>\"stock\": {\"tick\": \"ka10079\", \"min\": \"ka10080\", \"day\": \"ka10081\"}</p> <p>\"sector\": {\"tick\": \"ka20004\", \"min\": \"ka20005\", \"day\": \"ka20006\"}</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>\uc885\ubaa9\ucf54\ub4dc / \uc5c5\uc885\ucf54\ub4dc</p> required <code>period</code> <code>str</code> <p>\uce94\ub4e4 \uae30\uac04\uc720\ud615, {\"tick\", \"min\", \"day\"}.</p> required <code>ctype</code> <code>str</code> <p>\uc885\ubaa9 / \uc5c5\uc885 \uc720\ud615, {\"stock\", \"sector\"}.</p> required <code>start</code> <code>str</code> <p>\uc2dc\uc791\uc77c\uc790 in YYYYMMDD format.</p> <code>None</code> <code>end</code> <code>str</code> <p>\uc885\ub8cc\uc77c\uc790 in YYYYMMDD format.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>\uc720\ud6a8\ud558\uc9c0 \uc54a\uc740 'ctype' \ub610\ub294 'period'</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>\uce94\ub4e4 \ub370\uc774\ud130\ub97c \ud3ec\ud568\ud558\ub294 json \uc751\ub2f5</p> Source code in <code>kiwoom/api.py</code> <pre><code>async def candle(\n    self,\n    code: str,\n    period: str,\n    ctype: str,\n    start: str = None,\n    end: str = None,\n) -&gt; dict:\n    \"\"\"\n    \uc8fc\uc5b4\uc9c4 \ucf54\ub4dc, \uae30\uac04, \uc885\ubaa9/\uc5c5\uc885 \uc720\ud615\uc5d0 \ud574\ub2f9\ud558\ub294 API \uc694\uccad\uc744 \ud558\uace0 \uc751\ub2f5\uc744 \ubc18\ud658\ud569\ub2c8\ub2e4.\n\n    \"stock\": {\"tick\": \"ka10079\", \"min\": \"ka10080\", \"day\": \"ka10081\"}\n\n    \"sector\": {\"tick\": \"ka20004\", \"min\": \"ka20005\", \"day\": \"ka20006\"}\n\n    Args:\n        code (str): \uc885\ubaa9\ucf54\ub4dc / \uc5c5\uc885\ucf54\ub4dc\n        period (str): \uce94\ub4e4 \uae30\uac04\uc720\ud615, {\"tick\", \"min\", \"day\"}.\n        ctype (str): \uc885\ubaa9 / \uc5c5\uc885 \uc720\ud615, {\"stock\", \"sector\"}.\n        start (str, optional): \uc2dc\uc791\uc77c\uc790 in YYYYMMDD format.\n        end (str, optional): \uc885\ub8cc\uc77c\uc790 in YYYYMMDD format.\n\n    Raises:\n        ValueError: \uc720\ud6a8\ud558\uc9c0 \uc54a\uc740 'ctype' \ub610\ub294 'period'\n\n    Returns:\n        dict: \uce94\ub4e4 \ub370\uc774\ud130\ub97c \ud3ec\ud568\ud558\ub294 json \uc751\ub2f5\n    \"\"\"\n\n    ctype = ctype.lower()\n    endpoint = \"/api/dostk/chart\"\n    api_id = PERIOD_TO_API_ID[ctype][period]\n    data = dict(PERIOD_TO_DATA[ctype][period])\n    match ctype:\n        case \"stock\":\n            data[\"stk_cd\"] = code\n        case \"sector\":\n            data[\"inds_cd\"] = code\n        case _:\n            raise ValueError(f\"'ctype' must be one of [stock, sector], not {ctype=}.\")\n    if period == \"day\":\n        end = end if end else datetime.now().strftime(\"%Y%m%d\")\n        data[\"base_dt\"] = end\n\n    ymd: int = len(\"YYYYMMDD\")  # 8 digit compare\n    key: str = PERIOD_TO_BODY_KEY[ctype][period]\n    time: str = PERIOD_TO_TIME_KEY[period]\n\n    def should_continue(body: dict) -&gt; bool:\n        # Validate\n        if not valid(body, period, ctype):\n            return False\n        # Request full data\n        if not start:\n            return True\n        # Condition to continue\n        chart = body[key]\n        earliest = chart[-1][time][:ymd]\n        return start &lt;= earliest\n\n    body = await self.request_until(should_continue, endpoint, api_id, data=data)\n    return body\n</code></pre>"},{"location":"api/#kiwoom.API.trade","title":"trade  <code>async</code>","text":"<pre><code>trade(start, end='')\n</code></pre> <p>\uc8fc\uc5b4\uc9c4 \uc2dc\uc791\uc77c\uc790\uc640 \uc885\ub8cc\uc77c\uc790\uc5d0 \ud574\ub2f9\ud558\ub294 \uccb4\uacb0\ub0b4\uc5ed\uc744 \ud0a4\uc6c0\uc99d\uad8c '0343' \uacc4\uc88c \uccb4\uacb0\ub0b4\uc5ed \ud654\uba74\uacfc \ub3d9\uc77c\ud55c \uad6c\uc131\uc73c\ub85c \ubc18\ud658\ud569\ub2c8\ub2e4. \ub370\uc774\ud130 \uc870\ud68c \uc81c\ud55c\uc73c\ub85c \ucd5c\uadfc 2\uac1c\uc6d4 \ub370\uc774\ud130\ub9cc \uc870\ud68c\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.</p> <p>\uccb4\uacb0\ub0b4\uc5ed \ub370\uc774\ud130\ub294 \uc54c\ud30c\ub178\ud2b8\ub97c \ud1b5\ud574 \uac04\ud3b8\ud558\uac8c \uc9c4\uc785/\uccad\uc0b0 \uc2dc\uac01\ud654 \ubc0f \uc131\uacfc \uc9c0\ud45c\ub4e4\uc744 \ud655\uc778\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str</code> <p>\uc2dc\uc791\uc77c\uc790 in YYYYMMDD format</p> required <code>end</code> <code>str</code> <p>\uc885\ub8cc\uc77c\uc790 in YYYYMMDD format</p> <code>''</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>list[dict]: \uccb4\uacb0\ub0b4\uc5ed \ub370\uc774\ud130\ub97c \ud3ec\ud568\ud558\ub294 json \uc751\ub2f5 \ub9ac\uc2a4\ud2b8</p> Source code in <code>kiwoom/api.py</code> <pre><code>async def trade(self, start: str, end: str = \"\") -&gt; list[dict]:\n    \"\"\"\n    \uc8fc\uc5b4\uc9c4 \uc2dc\uc791\uc77c\uc790\uc640 \uc885\ub8cc\uc77c\uc790\uc5d0 \ud574\ub2f9\ud558\ub294 \uccb4\uacb0\ub0b4\uc5ed\uc744\n    \ud0a4\uc6c0\uc99d\uad8c '0343' \uacc4\uc88c \uccb4\uacb0\ub0b4\uc5ed \ud654\uba74\uacfc \ub3d9\uc77c\ud55c \uad6c\uc131\uc73c\ub85c \ubc18\ud658\ud569\ub2c8\ub2e4.\n    \ub370\uc774\ud130 \uc870\ud68c \uc81c\ud55c\uc73c\ub85c \ucd5c\uadfc 2\uac1c\uc6d4 \ub370\uc774\ud130\ub9cc \uc870\ud68c\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n    \uccb4\uacb0\ub0b4\uc5ed \ub370\uc774\ud130\ub294 [\uc54c\ud30c\ub178\ud2b8](http://alphanote.io)\ub97c \ud1b5\ud574\n    \uac04\ud3b8\ud558\uac8c \uc9c4\uc785/\uccad\uc0b0 \uc2dc\uac01\ud654 \ubc0f \uc131\uacfc \uc9c0\ud45c\ub4e4\uc744 \ud655\uc778\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n    Args:\n        start (str): \uc2dc\uc791\uc77c\uc790 in YYYYMMDD format\n        end (str, optional): \uc885\ub8cc\uc77c\uc790 in YYYYMMDD format\n\n    Returns:\n        list[dict]: \uccb4\uacb0\ub0b4\uc5ed \ub370\uc774\ud130\ub97c \ud3ec\ud568\ud558\ub294 json \uc751\ub2f5 \ub9ac\uc2a4\ud2b8\n    \"\"\"\n    endpoint = \"/api/dostk/acnt\"\n    api_id = \"kt00009\"\n    data = {\n        \"ord_dt\": \"\",  # YYYYMMDD (Optional)\n        \"qry_tp\": \"1\",  # \uc804\uccb4/\uccb4\uacb0\n        \"stk_bond_tp\": \"1\",  # \uc804\uccb4/\uc8fc\uc2dd/\ucc44\uad8c\n        \"mrkt_tp\": \"0\",  # \uc804\uccb4/\ucf54\uc2a4\ud53c/\ucf54\uc2a4\ub2e5/OTCBB/ECN\n        \"sell_tp\": \"0\",  # \uc804\uccb4/\ub9e4\ub3c4/\ub9e4\uc218\n        \"dmst_stex_tp\": \"%\",  # \uc804\uccb4/KRX/NXT/SOR\n        # 'stk_cd': '',  # \uc885\ubaa9\ucf54\ub4dc (Optional)\n        # 'fr_ord_no': '',  # \uc2dc\uc791\uc8fc\ubb38\ubc88\ud638 (Optional)\n    }\n\n    today = datetime.today()\n    start = datetime.strptime(start, \"%Y%m%d\")\n    start = max(start, today - timedelta(days=REQUEST_LIMIT_DAYS))\n    end = datetime.strptime(end, \"%Y%m%d\") if end else datetime.today()\n    end = min(end, datetime.today())\n\n    trs = []\n    key = \"acnt_ord_cntr_prst_array\"\n    for bday in bdate_range(start, end):\n        dic = dict(data)\n        dic[\"ord_dt\"] = bday.strftime(\"%Y%m%d\")  # manually set ord_dt\n        body = await self.request_until(lambda x: True, endpoint, api_id, data=dic)\n        if key in body:\n            # Append order date to each record\n            for rec in body[key]:\n                rec[\"ord_dt\"] = bday.strftime(\"%Y-%m-%d\")\n            trs.extend(body[key])\n    return trs\n</code></pre>"},{"location":"api/#kiwoom.API.add_callback_on_real_data","title":"add_callback_on_real_data","text":"<pre><code>add_callback_on_real_data(real_type, callback)\n</code></pre> <p>\uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \uc218\uc2e0 \uc2dc \ud638\ucd9c\ub420 \ucf5c\ubc31 \ud568\uc218\ub97c \ucd94\uac00\ud569\ub2c8\ub2e4. (trnm\uc774 'REAL'\uc778 \uacbd\uc6b0)</p> <ul> <li>callback \ud568\uc218\ub294 \uc11c\ubc84 \uc751\ub2f5 string \uadf8\ub300\ub85c\ub97c \uc778\uc790\ub85c \ubc1b\uc2b5\ub2c8\ub2e4.</li> <li>real_type\uc744 'PING' \ub610\ub294 'LOGIN'\uc73c\ub85c \uc124\uc815\ud558\uba74 \uae30\ubcf8 \ucf5c\ubc31 \ud568\uc218\ub97c \ub36e\uc5b4\uc501\ub2c8\ub2e4.</li> </ul> <p>\ucf5c\ubc31 \ud568\uc218\ub294 \ube44\ub3d9\uae30 \ucf5c\ubc31 \ud568\uc218\ub97c \ucd94\uac00\ud558\ub294 \uac83\uc744 \uad8c\uc7a5\ud569\ub2c8\ub2e4. \ube44\ub3d9\uae30 \ubc0f \ub3d9\uae30 \ucf5c\ubc31 \ud568\uc218 \ubaa8\ub450 \ub8e8\ud504\ub97c \ube14\ub85c\ud0b9\ud558\uc9c0 \uc54a\ub3c4\ub85d \ubc31\uadf8\ub77c\uc6b4\ub4dc\uc5d0\uc11c \uc2e4\ud589\ub429\ub2c8\ub2e4. \ub530\ub77c\uc11c \ub370\uc774\ud130 \ucc98\ub9ac \uc644\ub8cc \uc21c\uc11c\uac00 \ubc18\ub4dc\uc2dc \ub370\uc774\ud130 \uc218\uc2e0 \uc21c\uc11c\uc5d0 \ub530\ub77c \uc2e4\ud589\ub418\uc9c0 \uc54a\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4.</p> <p>ex) tick \uccb4\uacb0 \ub370\uc774\ud130 (type 'OB')\uac00 \uc218\uc2e0\ub420 \ub54c\ub9c8\ub2e4 \ub370\uc774\ud130 \ucd9c\ub825\ud558\uae30</p> <pre><code>&gt; fn = lambda raw: print(raw)\n\n&gt; add_callback_on_real_data(real_type='OB', callback=fn)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>real_type</code> <code>str</code> <p>\ud0a4\uc6c0 REST API\uc5d0 \uc815\uc758\ub41c \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ud0c0\uc785</p> required <code>callback</code> <code>Callable</code> <p>raw \uc2a4\ud2b8\ub9c1\uc744 \uc778\uc790\ub85c \ubc1b\ub294 \ucf5c\ubc31 \ud568\uc218</p> required Source code in <code>kiwoom/api.py</code> <pre><code>def add_callback_on_real_data(self, real_type: str, callback: Callable) -&gt; None:\n    \"\"\"\n    \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \uc218\uc2e0 \uc2dc \ud638\ucd9c\ub420 \ucf5c\ubc31 \ud568\uc218\ub97c \ucd94\uac00\ud569\ub2c8\ub2e4. (trnm\uc774 'REAL'\uc778 \uacbd\uc6b0)\n\n    * callback \ud568\uc218\ub294 \uc11c\ubc84 \uc751\ub2f5 string \uadf8\ub300\ub85c\ub97c \uc778\uc790\ub85c \ubc1b\uc2b5\ub2c8\ub2e4.\n    * real_type\uc744 'PING' \ub610\ub294 'LOGIN'\uc73c\ub85c \uc124\uc815\ud558\uba74 \uae30\ubcf8 \ucf5c\ubc31 \ud568\uc218\ub97c \ub36e\uc5b4\uc501\ub2c8\ub2e4.\n\n    \ucf5c\ubc31 \ud568\uc218\ub294 \ube44\ub3d9\uae30 \ucf5c\ubc31 \ud568\uc218\ub97c \ucd94\uac00\ud558\ub294 \uac83\uc744 \uad8c\uc7a5\ud569\ub2c8\ub2e4.\n    \ube44\ub3d9\uae30 \ubc0f \ub3d9\uae30 \ucf5c\ubc31 \ud568\uc218 \ubaa8\ub450 \ub8e8\ud504\ub97c \ube14\ub85c\ud0b9\ud558\uc9c0 \uc54a\ub3c4\ub85d\n    \ubc31\uadf8\ub77c\uc6b4\ub4dc\uc5d0\uc11c \uc2e4\ud589\ub429\ub2c8\ub2e4. \ub530\ub77c\uc11c \ub370\uc774\ud130 \ucc98\ub9ac \uc644\ub8cc \uc21c\uc11c\uac00 \ubc18\ub4dc\uc2dc\n    \ub370\uc774\ud130 \uc218\uc2e0 \uc21c\uc11c\uc5d0 \ub530\ub77c \uc2e4\ud589\ub418\uc9c0 \uc54a\uc744 \uc218 \uc788\uc2b5\ub2c8\ub2e4.\n\n    ex) tick \uccb4\uacb0 \ub370\uc774\ud130 (type 'OB')\uac00 \uc218\uc2e0\ub420 \ub54c\ub9c8\ub2e4 \ub370\uc774\ud130 \ucd9c\ub825\ud558\uae30\n\n        &gt; fn = lambda raw: print(raw)\n\n        &gt; add_callback_on_real_data(real_type='OB', callback=fn)\n\n    Args:\n        real_type (str): \ud0a4\uc6c0 REST API\uc5d0 \uc815\uc758\ub41c \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ud0c0\uc785\n        callback (Callable): raw \uc2a4\ud2b8\ub9c1\uc744 \uc778\uc790\ub85c \ubc1b\ub294 \ucf5c\ubc31 \ud568\uc218\n    \"\"\"\n\n    real_type = real_type.upper()\n    # Asnyc Callback\n    if iscoroutinefunction(callback):\n        self._callbacks[real_type] = wrap_async_callback(self._sem, callback)\n    # Sync Callback\n    else:\n        self._callbacks[real_type] = wrap_sync_callback(self._sem, callback)\n</code></pre>"},{"location":"api/#kiwoom.API.register_tick","title":"register_tick  <code>async</code>","text":"<pre><code>register_tick(grp_no, codes, refresh='1')\n</code></pre> <p>\uc8fc\uc5b4\uc9c4 \uadf8\ub8f9\ubc88\ud638\uc640 \uc885\ubaa9 \ucf54\ub4dc\uc5d0 \ub300\ud574 \uc8fc\uc2dd\uccb4\uacb0 \ub370\uc774\ud130\ub97c \ub4f1\ub85d\ud569\ub2c8\ub2e4. (\ud0c0\uc785 '0B')</p> <p>Parameters:</p> Name Type Description Default <code>grp_no</code> <code>str</code> <p>\uadf8\ub8f9\ubc88\ud638</p> required <code>codes</code> <code>list[str]</code> <p>\uc885\ubaa9\ucf54\ub4dc \ub9ac\uc2a4\ud2b8</p> required <code>refresh</code> <code>str</code> <p>\uae30\uc874\ub4f1\ub85d\uc720\uc9c0\uc5ec\ubd80 (\uae30\uc874\uc720\uc9c0:'1', \uc2e0\uaddc\ub4f1\ub85d:'0').</p> <code>'1'</code> Source code in <code>kiwoom/api.py</code> <pre><code>async def register_tick(\n    self,\n    grp_no: str,\n    codes: list[str],\n    refresh: str = \"1\",\n) -&gt; None:\n    \"\"\"\n    \uc8fc\uc5b4\uc9c4 \uadf8\ub8f9\ubc88\ud638\uc640 \uc885\ubaa9 \ucf54\ub4dc\uc5d0 \ub300\ud574 \uc8fc\uc2dd\uccb4\uacb0 \ub370\uc774\ud130\ub97c \ub4f1\ub85d\ud569\ub2c8\ub2e4. (\ud0c0\uc785 '0B')\n\n    Args:\n        grp_no (str): \uadf8\ub8f9\ubc88\ud638\n        codes (list[str]): \uc885\ubaa9\ucf54\ub4dc \ub9ac\uc2a4\ud2b8\n        refresh (str, optional): \uae30\uc874\ub4f1\ub85d\uc720\uc9c0\uc5ec\ubd80 (\uae30\uc874\uc720\uc9c0:'1', \uc2e0\uaddc\ub4f1\ub85d:'0').\n    \"\"\"\n\n    assert len(codes) &lt;= 100, f\"Max 100 codes per group, got {len(codes)} codes.\"\n    await self.socket.send(\n        {\n            \"trnm\": \"REG\",\n            \"grp_no\": grp_no,\n            \"refresh\": refresh,\n            \"data\": [\n                {\n                    \"item\": codes,\n                    \"type\": [\"0B\"],\n                }\n            ],\n        }\n    )\n</code></pre>"},{"location":"api/#kiwoom.API.register_hoga","title":"register_hoga  <code>async</code>","text":"<pre><code>register_hoga(grp_no, codes, refresh='1')\n</code></pre> <p>\uc8fc\uc5b4\uc9c4 \uadf8\ub8f9\ubc88\ud638\uc640 \uc885\ubaa9 \ucf54\ub4dc\uc5d0 \ub300\ud574 \uc8fc\uc2dd\ud638\uac00\uc794\ub7c9 \ub370\uc774\ud130\ub97c \ub4f1\ub85d\ud569\ub2c8\ub2e4. (\ud0c0\uc785 '0D')</p> <p>Parameters:</p> Name Type Description Default <code>grp_no</code> <code>str</code> <p>\uadf8\ub8f9\ubc88\ud638</p> required <code>codes</code> <code>list[str]</code> <p>\uc885\ubaa9\ucf54\ub4dc \ub9ac\uc2a4\ud2b8</p> required <code>refresh</code> <code>str</code> <p>\uae30\uc874\ub4f1\ub85d\uc720\uc9c0\uc5ec\ubd80 (\uae30\uc874\uc720\uc9c0:'1', \uc2e0\uaddc\ub4f1\ub85d:'0').</p> <code>'1'</code> Source code in <code>kiwoom/api.py</code> <pre><code>async def register_hoga(\n    self,\n    grp_no: str,\n    codes: list[str],\n    refresh: str = \"1\",\n) -&gt; None:\n    \"\"\"\n    \uc8fc\uc5b4\uc9c4 \uadf8\ub8f9\ubc88\ud638\uc640 \uc885\ubaa9 \ucf54\ub4dc\uc5d0 \ub300\ud574 \uc8fc\uc2dd\ud638\uac00\uc794\ub7c9 \ub370\uc774\ud130\ub97c \ub4f1\ub85d\ud569\ub2c8\ub2e4. (\ud0c0\uc785 '0D')\n\n    Args:\n        grp_no (str): \uadf8\ub8f9\ubc88\ud638\n        codes (list[str]): \uc885\ubaa9\ucf54\ub4dc \ub9ac\uc2a4\ud2b8\n        refresh (str, optional): \uae30\uc874\ub4f1\ub85d\uc720\uc9c0\uc5ec\ubd80 (\uae30\uc874\uc720\uc9c0:'1', \uc2e0\uaddc\ub4f1\ub85d:'0').\n    \"\"\"\n\n    assert len(codes) &lt;= 100, f\"Max 100 codes per group, got {len(codes)} codes.\"\n    await self.socket.send(\n        {\n            \"trnm\": \"REG\",\n            \"grp_no\": grp_no,\n            \"refresh\": refresh,\n            \"data\": [\n                {\n                    \"item\": codes,\n                    \"type\": [\"0D\"],\n                }\n            ],\n        }\n    )\n</code></pre>"},{"location":"api/#kiwoom.API.remove_register","title":"remove_register  <code>async</code>","text":"<pre><code>remove_register(grp_no, type)\n</code></pre> <p>\uc8fc\uc5b4\uc9c4 \uadf8\ub8f9\ubc88\ud638\uc640 \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ud0c0\uc785\uc5d0 \ub300\ud574 \ub4f1\ub85d\ub41c \ub370\uc774\ud130\ub97c \uc81c\uac70\ud569\ub2c8\ub2e4.</p> <p>Parameters:</p> Name Type Description Default <code>grp_no</code> <code>str</code> <p>\uadf8\ub8f9\ubc88\ud638</p> required <code>type</code> <code>str | list[str]</code> <p>\uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ud0c0\uc785 ex) '0B', '0D', 'DD'</p> required Source code in <code>kiwoom/api.py</code> <pre><code>async def remove_register(self, grp_no: str, type: str | list[str]) -&gt; None:\n    \"\"\"\n    \uc8fc\uc5b4\uc9c4 \uadf8\ub8f9\ubc88\ud638\uc640 \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ud0c0\uc785\uc5d0 \ub300\ud574 \ub4f1\ub85d\ub41c \ub370\uc774\ud130\ub97c \uc81c\uac70\ud569\ub2c8\ub2e4.\n\n    Args:\n        grp_no (str): \uadf8\ub8f9\ubc88\ud638\n        type (str | list[str]): \uc2e4\uc2dc\uac04 \ub370\uc774\ud130 \ud0c0\uc785 ex) '0B', '0D', 'DD'\n    \"\"\"\n    if not grp_no or not type:\n        return\n    if isinstance(type, str):\n        type = [type]\n    await self.socket.send(\n        {\"trnm\": \"REMOVE\", \"grp_no\": grp_no, \"refresh\": \"\", \"data\": [{\"type\": type}]}\n    )\n</code></pre>"},{"location":"api/#kiwoom.http","title":"http","text":""},{"location":"api/#kiwoom.http.Client","title":"Client","text":"Source code in <code>kiwoom/http/client.py</code> <pre><code>class Client:\n    def __init__(self, host: str, appkey: str, secretkey: str):\n        \"\"\"\n        Initialize Client instance.\n\n        Args:\n            host (str): domain\n            appkey (str): file path or raw appkey\n            secretkey (str): file path or raw secretkey\n        \"\"\"\n        self.host: str = host\n        self.debugging: bool = False\n\n        self._auth: str = \"\"\n        self._appkey: str = appkey\n        self._secretkey: str = secretkey\n\n        self._state_http = State.CLOSED\n        self._ready_event = asyncio.Event()\n        self._limiter: RateLimiter = RateLimiter()\n        self._session: ClientSession = None\n\n    async def connect(self, appkey: str, secretkey: str) -&gt; None:\n        \"\"\"\n        Connect to Kiwoom REST API server and receive token.\n\n        Args:\n            appkey (str): file path or raw appkey\n            secretkey (str): file path or raw secretkey\n        \"\"\"\n        if isfile(appkey):\n            with open(appkey, \"r\") as f:\n                self._appkey = f.read().strip()\n        if isfile(secretkey):\n            with open(secretkey, \"r\") as f:\n                self._secretkey = f.read().strip()\n\n        # Already connected\n        if self._session and not self._session.closed:\n            return\n\n        # Establish HTTP session\n        self._ready_event.clear()\n        self._session = ClientSession(\n            timeout=aiohttp.ClientTimeout(\n                total=HTTP_TOTAL_TIMEOUT,\n                sock_connect=HTTP_CONNECT_TIMEOUT,\n                sock_read=HTTP_READ_TIMEOUT,\n            ),\n            connector=aiohttp.TCPConnector(limit=HTTP_TCP_CONNECTORS, enable_cleanup_closed=True),\n        )\n\n        # Request token\n        endpoint = \"/oauth2/token\"\n        api_id = \"\"\n        headers = self.headers(api_id)\n        data = {\n            \"grant_type\": \"client_credentials\",\n            \"appkey\": self._appkey,\n            \"secretkey\": self._secretkey,\n        }\n        async with self._session.post(self.host + endpoint, headers=headers, json=data) as res:\n            res.raise_for_status()\n            body = await res.json()\n            resp = Response(res.url, res.status, res.headers, body)\n\n        # Set token\n        if \"token\" not in body:\n            msg = dumps(self, endpoint, api_id, headers, data, resp)\n            raise RuntimeError(f\"Failed to get token: {msg}\")\n        token = body[\"token\"]\n        self._auth = f\"Bearer {token}\"\n        self._session.headers.update(\n            {\n                \"Content-Type\": \"application/json;charset=UTF-8\",\n                \"authorization\": self._auth,\n            }\n        )\n        self._state_http = State.CONNECTED\n        self._ready_event.set()\n\n    async def close(self) -&gt; None:\n        \"\"\"\n        Close HTTP session.\n        \"\"\"\n        self._ready_event.clear()\n        if self._session:\n            await asyncio.shield(self._session.close())\n\n        self._auth = \"\"\n        self._session = None\n\n    def token(self) -&gt; str:\n        \"\"\"\n        Returns token if available, otherwise empty string.\n\n        Raises:\n            ValueError: Invalid token.\n\n        Returns:\n            str: token\n        \"\"\"\n        if not self._auth:\n            return \"\"\n        if \"Bearer \" in self._auth:\n            return self._auth[len(\"Bearer \") :]\n        raise ValueError(f\"Invalid token: {self._auth}\")\n\n    def headers(\n        self, api_id: str, cont_yn: str = \"N\", next_key: str = \"\", headers: dict | None = None\n    ) -&gt; dict[str, str]:\n        \"\"\"\n        Generate headers for the request.\n\n        Args:\n            api_id (str): api_id in Kiwoom API\n            cont_yn (str, optional): cont_yn in Kiwoom API\n            next_key (str, optional): next_key in Kiwoom API\n            headers (dict | None, optional): headers to be updated with\n\n        Returns:\n            dict[str, str]: headers\n        \"\"\"\n        base = {\n            # 'Content-Type': 'application/json;charset=UTF-8',\n            # 'authorization': self._auth,\n            \"cont-yn\": cont_yn,\n            \"next-key\": next_key,\n            \"api-id\": api_id,\n        }\n        if headers is not None:\n            headers.update(base)\n            return headers\n        return base\n\n    async def ready(self):\n        \"\"\"\n        Wait until request limit is lifted and connection is established.\n\n        Raises:\n            RuntimeError: Connection timeout.\n        \"\"\"\n        try:\n            await asyncio.wait_for(self._ready_event.wait(), HTTP_TOTAL_TIMEOUT)\n        except asyncio.TimeoutError as err:\n            msg = f\"Connection timeout: waited for {HTTP_TOTAL_TIMEOUT} seconds.\"\n            raise RuntimeError(msg) from err\n        await self._limiter.acquire()\n\n    @debugger\n    async def post(\n        self, endpoint: str, api_id: str, headers: dict | None = None, data: dict | None = None\n    ) -&gt; aiohttp.ClientResponse:\n        \"\"\"\n        Post request to the server, but using client.request function is recommended.\n        Request limit and connection status are checked globally and automatically.\n\n        Args:\n            endpoint (str): endpoint to Kiwoom REST API server\n            api_id (str): api id\n            headers (dict | None, optional): headers of the request.\n            data (dict | None, optional): data to be sent in json format\n\n        Returns:\n            aiohttp.ClientResponse: async response from the server,\n                but this will be converted to kiwoom.http.response.Response by debugger.\n        \"\"\"\n\n        # Warn not connected\n        if not self._state_http == State.CONNECTED:\n            warnings.warn(\"Not connected, wait for timeout...\", RuntimeWarning, stacklevel=1)\n\n        # Wait connection and request limits\n        await self.ready()\n\n        # Post Request\n        if headers is None:\n            headers = self.headers(api_id)\n        return await self._session.post(self.host + endpoint, headers=headers, json=data)\n\n    async def request(\n        self, endpoint: str, api_id: str, headers: dict | None = None, data: dict | None = None\n    ) -&gt; Response:\n        \"\"\"\n        Requests to the server and returns response with error handling.\n\n        Args:\n            endpoint (str): endpoint of the server\n            api_id (str): api id\n            headers (dict | None, optional): headers of the request. Defaults to None.\n            data (dict | None, optional): data of the request. Defaults to None.\n\n        Raises:\n            RuntimeError: RuntimeError when return_code is not in [0, 3, 20]\n\n        Returns:\n            Response: response wrapped by kiwoom.http.response.Response\n        \"\"\"\n\n        res: Response = await self.post(endpoint, api_id, headers=headers, data=data)\n        body = res.json()\n        if \"return_code\" in body:\n            match body[\"return_code\"]:\n                case 0 | 20:\n                    # 0: Success\n                    # 20 : No Data\n                    return res\n                case 3:\n                    # 3 : Token Expired\n                    print(\"Token expired, trying to refresh token...\")\n                    await self.connect(self._appkey, self._secretkey)\n                    return await self.request(endpoint, api_id, headers=headers, data=data)\n\n        # Request Failure\n        return_code = body[\"return_code\"]\n        err = f\"\\nRequest failed with {return_code=}, not in {{'0', '3', '20'}}.\"\n        if not self.debugging:\n            msg = dumps(self, endpoint, api_id, headers, data, res)\n            raise RuntimeError(msg + err)\n        raise RuntimeError(err)\n\n    async def request_until(\n        self,\n        should_continue: Callable,\n        endpoint: str,\n        api_id: str,\n        headers: dict | None = None,\n        data: dict | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Request until 'cont-yn' in response header is 'Y',\n        and should_continue(body) evaluates to True.\n\n        Args:\n            should_continue (Callable):\n                callable that takes body(dict) and\n                returns boolean value to request again or not\n            endpoint (str):\n                endpoint of the server\n            api_id (str):\n                api id\n            headers (dict | None, optional):\n                headers of the request. Defaults to None.\n            data (dict | None, optional):\n                data of the request. Defaults to None.\n\n        Returns:\n            dict: response body\n        \"\"\"\n\n        # Initial request\n        res = await self.request(endpoint, api_id, headers=headers, data=data)\n        body = res.json()\n\n        # If condition to chain is not met\n        if callable(should_continue) and not should_continue(body):\n            return body\n\n        # Extract list data only\n        bodies = dict()\n        for key in body.keys():\n            if isinstance(body[key], list):\n                bodies[key] = [body[key]]\n                continue\n            bodies[key] = body[key]\n\n        # Rercursive call\n        while res.headers.get(\"cont-yn\") == \"Y\" and should_continue(body):\n            next_key = res.headers.get(\"next-key\")\n            headers = self.headers(api_id, cont_yn=\"Y\", next_key=next_key, headers=headers)\n\n            # Continue request\n            res = await self.request(endpoint, api_id, headers=headers, data=data)\n            body = res.json()\n\n            # Append list data\n            for key in body.keys():\n                if isinstance(body[key], list):\n                    bodies[key].append(body[key])\n\n        # Flatten list data as if it was one list\n        for key in bodies:\n            if isinstance(bodies[key], list):\n                bodies[key] = list(chain.from_iterable(bodies[key]))\n        return bodies\n</code></pre>"},{"location":"api/#kiwoom.http.Client.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host = host\n</code></pre>"},{"location":"api/#kiwoom.http.Client.debugging","title":"debugging  <code>instance-attribute</code>","text":"<pre><code>debugging = False\n</code></pre>"},{"location":"api/#kiwoom.http.Client.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(appkey, secretkey)\n</code></pre> <p>Connect to Kiwoom REST API server and receive token.</p> <p>Parameters:</p> Name Type Description Default <code>appkey</code> <code>str</code> <p>file path or raw appkey</p> required <code>secretkey</code> <code>str</code> <p>file path or raw secretkey</p> required Source code in <code>kiwoom/http/client.py</code> <pre><code>async def connect(self, appkey: str, secretkey: str) -&gt; None:\n    \"\"\"\n    Connect to Kiwoom REST API server and receive token.\n\n    Args:\n        appkey (str): file path or raw appkey\n        secretkey (str): file path or raw secretkey\n    \"\"\"\n    if isfile(appkey):\n        with open(appkey, \"r\") as f:\n            self._appkey = f.read().strip()\n    if isfile(secretkey):\n        with open(secretkey, \"r\") as f:\n            self._secretkey = f.read().strip()\n\n    # Already connected\n    if self._session and not self._session.closed:\n        return\n\n    # Establish HTTP session\n    self._ready_event.clear()\n    self._session = ClientSession(\n        timeout=aiohttp.ClientTimeout(\n            total=HTTP_TOTAL_TIMEOUT,\n            sock_connect=HTTP_CONNECT_TIMEOUT,\n            sock_read=HTTP_READ_TIMEOUT,\n        ),\n        connector=aiohttp.TCPConnector(limit=HTTP_TCP_CONNECTORS, enable_cleanup_closed=True),\n    )\n\n    # Request token\n    endpoint = \"/oauth2/token\"\n    api_id = \"\"\n    headers = self.headers(api_id)\n    data = {\n        \"grant_type\": \"client_credentials\",\n        \"appkey\": self._appkey,\n        \"secretkey\": self._secretkey,\n    }\n    async with self._session.post(self.host + endpoint, headers=headers, json=data) as res:\n        res.raise_for_status()\n        body = await res.json()\n        resp = Response(res.url, res.status, res.headers, body)\n\n    # Set token\n    if \"token\" not in body:\n        msg = dumps(self, endpoint, api_id, headers, data, resp)\n        raise RuntimeError(f\"Failed to get token: {msg}\")\n    token = body[\"token\"]\n    self._auth = f\"Bearer {token}\"\n    self._session.headers.update(\n        {\n            \"Content-Type\": \"application/json;charset=UTF-8\",\n            \"authorization\": self._auth,\n        }\n    )\n    self._state_http = State.CONNECTED\n    self._ready_event.set()\n</code></pre>"},{"location":"api/#kiwoom.http.Client.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close HTTP session.</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"\n    Close HTTP session.\n    \"\"\"\n    self._ready_event.clear()\n    if self._session:\n        await asyncio.shield(self._session.close())\n\n    self._auth = \"\"\n    self._session = None\n</code></pre>"},{"location":"api/#kiwoom.http.Client.token","title":"token","text":"<pre><code>token()\n</code></pre> <p>Returns token if available, otherwise empty string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid token.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>token</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>def token(self) -&gt; str:\n    \"\"\"\n    Returns token if available, otherwise empty string.\n\n    Raises:\n        ValueError: Invalid token.\n\n    Returns:\n        str: token\n    \"\"\"\n    if not self._auth:\n        return \"\"\n    if \"Bearer \" in self._auth:\n        return self._auth[len(\"Bearer \") :]\n    raise ValueError(f\"Invalid token: {self._auth}\")\n</code></pre>"},{"location":"api/#kiwoom.http.Client.headers","title":"headers","text":"<pre><code>headers(api_id, cont_yn='N', next_key='', headers=None)\n</code></pre> <p>Generate headers for the request.</p> <p>Parameters:</p> Name Type Description Default <code>api_id</code> <code>str</code> <p>api_id in Kiwoom API</p> required <code>cont_yn</code> <code>str</code> <p>cont_yn in Kiwoom API</p> <code>'N'</code> <code>next_key</code> <code>str</code> <p>next_key in Kiwoom API</p> <code>''</code> <code>headers</code> <code>dict | None</code> <p>headers to be updated with</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: headers</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>def headers(\n    self, api_id: str, cont_yn: str = \"N\", next_key: str = \"\", headers: dict | None = None\n) -&gt; dict[str, str]:\n    \"\"\"\n    Generate headers for the request.\n\n    Args:\n        api_id (str): api_id in Kiwoom API\n        cont_yn (str, optional): cont_yn in Kiwoom API\n        next_key (str, optional): next_key in Kiwoom API\n        headers (dict | None, optional): headers to be updated with\n\n    Returns:\n        dict[str, str]: headers\n    \"\"\"\n    base = {\n        # 'Content-Type': 'application/json;charset=UTF-8',\n        # 'authorization': self._auth,\n        \"cont-yn\": cont_yn,\n        \"next-key\": next_key,\n        \"api-id\": api_id,\n    }\n    if headers is not None:\n        headers.update(base)\n        return headers\n    return base\n</code></pre>"},{"location":"api/#kiwoom.http.Client.ready","title":"ready  <code>async</code>","text":"<pre><code>ready()\n</code></pre> <p>Wait until request limit is lifted and connection is established.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Connection timeout.</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>async def ready(self):\n    \"\"\"\n    Wait until request limit is lifted and connection is established.\n\n    Raises:\n        RuntimeError: Connection timeout.\n    \"\"\"\n    try:\n        await asyncio.wait_for(self._ready_event.wait(), HTTP_TOTAL_TIMEOUT)\n    except asyncio.TimeoutError as err:\n        msg = f\"Connection timeout: waited for {HTTP_TOTAL_TIMEOUT} seconds.\"\n        raise RuntimeError(msg) from err\n    await self._limiter.acquire()\n</code></pre>"},{"location":"api/#kiwoom.http.Client.post","title":"post  <code>async</code>","text":"<pre><code>post(endpoint, api_id, headers=None, data=None)\n</code></pre> <p>Post request to the server, but using client.request function is recommended. Request limit and connection status are checked globally and automatically.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>endpoint to Kiwoom REST API server</p> required <code>api_id</code> <code>str</code> <p>api id</p> required <code>headers</code> <code>dict | None</code> <p>headers of the request.</p> <code>None</code> <code>data</code> <code>dict | None</code> <p>data to be sent in json format</p> <code>None</code> <p>Returns:</p> Type Description <code>ClientResponse</code> <p>aiohttp.ClientResponse: async response from the server, but this will be converted to kiwoom.http.response.Response by debugger.</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>@debugger\nasync def post(\n    self, endpoint: str, api_id: str, headers: dict | None = None, data: dict | None = None\n) -&gt; aiohttp.ClientResponse:\n    \"\"\"\n    Post request to the server, but using client.request function is recommended.\n    Request limit and connection status are checked globally and automatically.\n\n    Args:\n        endpoint (str): endpoint to Kiwoom REST API server\n        api_id (str): api id\n        headers (dict | None, optional): headers of the request.\n        data (dict | None, optional): data to be sent in json format\n\n    Returns:\n        aiohttp.ClientResponse: async response from the server,\n            but this will be converted to kiwoom.http.response.Response by debugger.\n    \"\"\"\n\n    # Warn not connected\n    if not self._state_http == State.CONNECTED:\n        warnings.warn(\"Not connected, wait for timeout...\", RuntimeWarning, stacklevel=1)\n\n    # Wait connection and request limits\n    await self.ready()\n\n    # Post Request\n    if headers is None:\n        headers = self.headers(api_id)\n    return await self._session.post(self.host + endpoint, headers=headers, json=data)\n</code></pre>"},{"location":"api/#kiwoom.http.Client.request","title":"request  <code>async</code>","text":"<pre><code>request(endpoint, api_id, headers=None, data=None)\n</code></pre> <p>Requests to the server and returns response with error handling.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>endpoint of the server</p> required <code>api_id</code> <code>str</code> <p>api id</p> required <code>headers</code> <code>dict | None</code> <p>headers of the request. Defaults to None.</p> <code>None</code> <code>data</code> <code>dict | None</code> <p>data of the request. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>RuntimeError when return_code is not in [0, 3, 20]</p> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>response wrapped by kiwoom.http.response.Response</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>async def request(\n    self, endpoint: str, api_id: str, headers: dict | None = None, data: dict | None = None\n) -&gt; Response:\n    \"\"\"\n    Requests to the server and returns response with error handling.\n\n    Args:\n        endpoint (str): endpoint of the server\n        api_id (str): api id\n        headers (dict | None, optional): headers of the request. Defaults to None.\n        data (dict | None, optional): data of the request. Defaults to None.\n\n    Raises:\n        RuntimeError: RuntimeError when return_code is not in [0, 3, 20]\n\n    Returns:\n        Response: response wrapped by kiwoom.http.response.Response\n    \"\"\"\n\n    res: Response = await self.post(endpoint, api_id, headers=headers, data=data)\n    body = res.json()\n    if \"return_code\" in body:\n        match body[\"return_code\"]:\n            case 0 | 20:\n                # 0: Success\n                # 20 : No Data\n                return res\n            case 3:\n                # 3 : Token Expired\n                print(\"Token expired, trying to refresh token...\")\n                await self.connect(self._appkey, self._secretkey)\n                return await self.request(endpoint, api_id, headers=headers, data=data)\n\n    # Request Failure\n    return_code = body[\"return_code\"]\n    err = f\"\\nRequest failed with {return_code=}, not in {{'0', '3', '20'}}.\"\n    if not self.debugging:\n        msg = dumps(self, endpoint, api_id, headers, data, res)\n        raise RuntimeError(msg + err)\n    raise RuntimeError(err)\n</code></pre>"},{"location":"api/#kiwoom.http.Client.request_until","title":"request_until  <code>async</code>","text":"<pre><code>request_until(should_continue, endpoint, api_id, headers=None, data=None)\n</code></pre> <p>Request until 'cont-yn' in response header is 'Y', and should_continue(body) evaluates to True.</p> <p>Parameters:</p> Name Type Description Default <code>should_continue</code> <code>Callable</code> <p>callable that takes body(dict) and returns boolean value to request again or not</p> required <code>endpoint</code> <code>str</code> <p>endpoint of the server</p> required <code>api_id</code> <code>str</code> <p>api id</p> required <code>headers</code> <code>dict | None</code> <p>headers of the request. Defaults to None.</p> <code>None</code> <code>data</code> <code>dict | None</code> <p>data of the request. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>response body</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>async def request_until(\n    self,\n    should_continue: Callable,\n    endpoint: str,\n    api_id: str,\n    headers: dict | None = None,\n    data: dict | None = None,\n) -&gt; dict:\n    \"\"\"\n    Request until 'cont-yn' in response header is 'Y',\n    and should_continue(body) evaluates to True.\n\n    Args:\n        should_continue (Callable):\n            callable that takes body(dict) and\n            returns boolean value to request again or not\n        endpoint (str):\n            endpoint of the server\n        api_id (str):\n            api id\n        headers (dict | None, optional):\n            headers of the request. Defaults to None.\n        data (dict | None, optional):\n            data of the request. Defaults to None.\n\n    Returns:\n        dict: response body\n    \"\"\"\n\n    # Initial request\n    res = await self.request(endpoint, api_id, headers=headers, data=data)\n    body = res.json()\n\n    # If condition to chain is not met\n    if callable(should_continue) and not should_continue(body):\n        return body\n\n    # Extract list data only\n    bodies = dict()\n    for key in body.keys():\n        if isinstance(body[key], list):\n            bodies[key] = [body[key]]\n            continue\n        bodies[key] = body[key]\n\n    # Rercursive call\n    while res.headers.get(\"cont-yn\") == \"Y\" and should_continue(body):\n        next_key = res.headers.get(\"next-key\")\n        headers = self.headers(api_id, cont_yn=\"Y\", next_key=next_key, headers=headers)\n\n        # Continue request\n        res = await self.request(endpoint, api_id, headers=headers, data=data)\n        body = res.json()\n\n        # Append list data\n        for key in body.keys():\n            if isinstance(body[key], list):\n                bodies[key].append(body[key])\n\n    # Flatten list data as if it was one list\n    for key in bodies:\n        if isinstance(bodies[key], list):\n            bodies[key] = list(chain.from_iterable(bodies[key]))\n    return bodies\n</code></pre>"},{"location":"api/#kiwoom.http.Response","title":"Response","text":"<p>Response wrapper for aiohttp.ClientResponse</p> Source code in <code>kiwoom/http/response.py</code> <pre><code>class Response:\n    \"\"\"\n    Response wrapper for aiohttp.ClientResponse\n    \"\"\"\n\n    def __init__(self, url: str, status: int, headers: dict, body: dict):\n        \"\"\"\n        Simply wrap aiohttp.ClientResponse to escape from async context.\n\n        Args:\n            url (str): url of the response\n            status (int): status code of the response\n            headers (dict): headers of the response\n            body (dict): body of the response\n        \"\"\"\n\n        self.url = url\n        self.status = status\n        self.headers = headers\n        self.body = body\n\n    def json(self) -&gt; dict:\n        \"\"\"\n        Returns already parsed body.\n\n        Returns:\n            dict: body in json format\n        \"\"\"\n        return self.body\n</code></pre>"},{"location":"api/#kiwoom.http.Response.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"api/#kiwoom.http.Response.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status = status\n</code></pre>"},{"location":"api/#kiwoom.http.Response.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers = headers\n</code></pre>"},{"location":"api/#kiwoom.http.Response.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body = body\n</code></pre>"},{"location":"api/#kiwoom.http.Response.json","title":"json","text":"<pre><code>json()\n</code></pre> <p>Returns already parsed body.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>body in json format</p> Source code in <code>kiwoom/http/response.py</code> <pre><code>def json(self) -&gt; dict:\n    \"\"\"\n    Returns already parsed body.\n\n    Returns:\n        dict: body in json format\n    \"\"\"\n    return self.body\n</code></pre>"},{"location":"api/#kiwoom.http.Socket","title":"Socket","text":"Source code in <code>kiwoom/http/socket.py</code> <pre><code>class Socket:\n    REAL = \"wss://api.kiwoom.com:10000\"\n    MOCK = \"wss://mockapi.kiwoom.com:10000\"  # KRX Only\n    ENDPOINT = \"/api/dostk/websocket\"\n\n    def __init__(self, url: str, queue: asyncio.Queue):\n        \"\"\"\n        Initialize Socket class.\n\n        Args:\n            url (str): url of Kiwoom websocket server\n            queue (asyncio.Queue): queue to put received data\n        \"\"\"\n        self.url = url\n        self._queue = queue\n        self._session: ClientSession | None = None\n        self._websocket: ClientWebSocketResponse | None = None\n\n        self._state = State.CLOSED\n        self._state_lock = asyncio.Lock()\n        self._queue_task: asyncio.Task | None = None\n        self._stop_event = asyncio.Event()\n        self._stop_event.set()\n\n    async def connect(self, session: ClientSession, token: str):\n        \"\"\"\n        Connect to Kiwoom websocket server.\n\n        Args:\n            session (ClientSession): aiohttp ClientSession from API.connect()\n            token (str): token for authentication\n        \"\"\"\n\n        # print(\"Trying to connect websocket...\")\n        async with self._state_lock:\n            if self._state in (State.CONNECTED, State.CONNECTING):\n                return\n\n            self._state = State.CONNECTING\n            try:\n                # Close existing websocket &amp; task\n                self._stop_event.set()\n                if self._websocket and not self._websocket.closed:\n                    await self._websocket.close()\n                await cancel(self._queue_task)\n                self._queue_task = None\n\n                self._session = session\n                self._websocket = await session.ws_connect(\n                    self.url, autoping=True, heartbeat=WEBSOCKET_HEARTBEAT\n                )\n\n                self._stop_event.clear()\n                self._queue_task = asyncio.create_task(self.run(), name=\"enqueue\")\n                await self.send({\"trnm\": \"LOGIN\", \"token\": token})\n                self._state = State.CONNECTED\n\n            except Exception as err:\n                print(f\"Websocket failed to connect to {self.url}: {err}\")\n                self._state = State.CLOSED\n\n    async def close(self):\n        \"\"\"\n        Close the websocket and the task.\n        \"\"\"\n        async with self._state_lock:\n            self._stop_event.set()\n            if self._queue_task:\n                self._queue_task.cancel()\n                with contextlib.suppress(asyncio.CancelledError):\n                    await self._queue_task\n\n            if self._websocket and not self._websocket.closed:\n                with contextlib.suppress(Exception):\n                    await self._websocket.close()\n\n            self._session = None\n            self._websocket = None\n            self._queue_task = None\n\n    async def send(self, msg: str | dict) -&gt; None:\n        \"\"\"\n        Send data to Kiwoom websocket server.\n\n        Args:\n            msg (str | dict): msg should be in json format\n        \"\"\"\n        if isinstance(msg, dict):\n            # msg = json.dumps(msg)  # slow\n            msg = orjson.dumps(msg).decode(\"utf-8\")\n        await self._websocket.send_str(msg)\n\n    async def recv(self) -&gt; str:\n        \"\"\"\n        Receive data from Kiwoom websocket server and return data.\n        If message type is not str, close the websocket and raise RuntimeError.\n\n        Raises:\n            RuntimeError: Websocket Connection Error\n\n        Returns:\n            str: received json formatted data from websocket\n        \"\"\"\n        try:\n            return await self._websocket.receive_str()\n        except WSMessageTypeError as err:\n            msg = await self._websocket.receive()\n            if msg.type == WSMsgType.BINARY:\n                msg.data = msg.data.decode(\"utf-8\")\n            await self.close()\n            raise RuntimeError(f\"Websocket received other type than str: {msg}\") from err\n\n    async def run(self):\n        \"\"\"\n        Receive data from websocket and put data to the queue.\n        If WEBSOCKET_QUEUE_MAX_SIZE is set and queue gets full,\n        then backpressure will be applied to the websocket.\n        Run this task in background with asyncio.create_task().\n        \"\"\"\n        assert self._websocket is not None\n        try:\n            while not self._stop_event.is_set():\n                await self._queue.put(await self.recv())\n\n        except Exception as e:\n            print(f\"Failed to receive message: {e}\")\n            await self.close()\n</code></pre>"},{"location":"api/#kiwoom.http.Socket.REAL","title":"REAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REAL = 'wss://api.kiwoom.com:10000'\n</code></pre>"},{"location":"api/#kiwoom.http.Socket.MOCK","title":"MOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOCK = 'wss://mockapi.kiwoom.com:10000'\n</code></pre>"},{"location":"api/#kiwoom.http.Socket.ENDPOINT","title":"ENDPOINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENDPOINT = '/api/dostk/websocket'\n</code></pre>"},{"location":"api/#kiwoom.http.Socket.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"api/#kiwoom.http.Socket.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(session, token)\n</code></pre> <p>Connect to Kiwoom websocket server.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>ClientSession</code> <p>aiohttp ClientSession from API.connect()</p> required <code>token</code> <code>str</code> <p>token for authentication</p> required Source code in <code>kiwoom/http/socket.py</code> <pre><code>async def connect(self, session: ClientSession, token: str):\n    \"\"\"\n    Connect to Kiwoom websocket server.\n\n    Args:\n        session (ClientSession): aiohttp ClientSession from API.connect()\n        token (str): token for authentication\n    \"\"\"\n\n    # print(\"Trying to connect websocket...\")\n    async with self._state_lock:\n        if self._state in (State.CONNECTED, State.CONNECTING):\n            return\n\n        self._state = State.CONNECTING\n        try:\n            # Close existing websocket &amp; task\n            self._stop_event.set()\n            if self._websocket and not self._websocket.closed:\n                await self._websocket.close()\n            await cancel(self._queue_task)\n            self._queue_task = None\n\n            self._session = session\n            self._websocket = await session.ws_connect(\n                self.url, autoping=True, heartbeat=WEBSOCKET_HEARTBEAT\n            )\n\n            self._stop_event.clear()\n            self._queue_task = asyncio.create_task(self.run(), name=\"enqueue\")\n            await self.send({\"trnm\": \"LOGIN\", \"token\": token})\n            self._state = State.CONNECTED\n\n        except Exception as err:\n            print(f\"Websocket failed to connect to {self.url}: {err}\")\n            self._state = State.CLOSED\n</code></pre>"},{"location":"api/#kiwoom.http.Socket.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the websocket and the task.</p> Source code in <code>kiwoom/http/socket.py</code> <pre><code>async def close(self):\n    \"\"\"\n    Close the websocket and the task.\n    \"\"\"\n    async with self._state_lock:\n        self._stop_event.set()\n        if self._queue_task:\n            self._queue_task.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await self._queue_task\n\n        if self._websocket and not self._websocket.closed:\n            with contextlib.suppress(Exception):\n                await self._websocket.close()\n\n        self._session = None\n        self._websocket = None\n        self._queue_task = None\n</code></pre>"},{"location":"api/#kiwoom.http.Socket.send","title":"send  <code>async</code>","text":"<pre><code>send(msg)\n</code></pre> <p>Send data to Kiwoom websocket server.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str | dict</code> <p>msg should be in json format</p> required Source code in <code>kiwoom/http/socket.py</code> <pre><code>async def send(self, msg: str | dict) -&gt; None:\n    \"\"\"\n    Send data to Kiwoom websocket server.\n\n    Args:\n        msg (str | dict): msg should be in json format\n    \"\"\"\n    if isinstance(msg, dict):\n        # msg = json.dumps(msg)  # slow\n        msg = orjson.dumps(msg).decode(\"utf-8\")\n    await self._websocket.send_str(msg)\n</code></pre>"},{"location":"api/#kiwoom.http.Socket.recv","title":"recv  <code>async</code>","text":"<pre><code>recv()\n</code></pre> <p>Receive data from Kiwoom websocket server and return data. If message type is not str, close the websocket and raise RuntimeError.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Websocket Connection Error</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>received json formatted data from websocket</p> Source code in <code>kiwoom/http/socket.py</code> <pre><code>async def recv(self) -&gt; str:\n    \"\"\"\n    Receive data from Kiwoom websocket server and return data.\n    If message type is not str, close the websocket and raise RuntimeError.\n\n    Raises:\n        RuntimeError: Websocket Connection Error\n\n    Returns:\n        str: received json formatted data from websocket\n    \"\"\"\n    try:\n        return await self._websocket.receive_str()\n    except WSMessageTypeError as err:\n        msg = await self._websocket.receive()\n        if msg.type == WSMsgType.BINARY:\n            msg.data = msg.data.decode(\"utf-8\")\n        await self.close()\n        raise RuntimeError(f\"Websocket received other type than str: {msg}\") from err\n</code></pre>"},{"location":"api/#kiwoom.http.Socket.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>Receive data from websocket and put data to the queue. If WEBSOCKET_QUEUE_MAX_SIZE is set and queue gets full, then backpressure will be applied to the websocket. Run this task in background with asyncio.create_task().</p> Source code in <code>kiwoom/http/socket.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Receive data from websocket and put data to the queue.\n    If WEBSOCKET_QUEUE_MAX_SIZE is set and queue gets full,\n    then backpressure will be applied to the websocket.\n    Run this task in background with asyncio.create_task().\n    \"\"\"\n    assert self._websocket is not None\n    try:\n        while not self._stop_event.is_set():\n            await self._queue.put(await self.recv())\n\n    except Exception as e:\n        print(f\"Failed to receive message: {e}\")\n        await self.close()\n</code></pre>"},{"location":"api/#kiwoom.http.client","title":"client","text":""},{"location":"api/#kiwoom.http.client.Client","title":"Client","text":"Source code in <code>kiwoom/http/client.py</code> <pre><code>class Client:\n    def __init__(self, host: str, appkey: str, secretkey: str):\n        \"\"\"\n        Initialize Client instance.\n\n        Args:\n            host (str): domain\n            appkey (str): file path or raw appkey\n            secretkey (str): file path or raw secretkey\n        \"\"\"\n        self.host: str = host\n        self.debugging: bool = False\n\n        self._auth: str = \"\"\n        self._appkey: str = appkey\n        self._secretkey: str = secretkey\n\n        self._state_http = State.CLOSED\n        self._ready_event = asyncio.Event()\n        self._limiter: RateLimiter = RateLimiter()\n        self._session: ClientSession = None\n\n    async def connect(self, appkey: str, secretkey: str) -&gt; None:\n        \"\"\"\n        Connect to Kiwoom REST API server and receive token.\n\n        Args:\n            appkey (str): file path or raw appkey\n            secretkey (str): file path or raw secretkey\n        \"\"\"\n        if isfile(appkey):\n            with open(appkey, \"r\") as f:\n                self._appkey = f.read().strip()\n        if isfile(secretkey):\n            with open(secretkey, \"r\") as f:\n                self._secretkey = f.read().strip()\n\n        # Already connected\n        if self._session and not self._session.closed:\n            return\n\n        # Establish HTTP session\n        self._ready_event.clear()\n        self._session = ClientSession(\n            timeout=aiohttp.ClientTimeout(\n                total=HTTP_TOTAL_TIMEOUT,\n                sock_connect=HTTP_CONNECT_TIMEOUT,\n                sock_read=HTTP_READ_TIMEOUT,\n            ),\n            connector=aiohttp.TCPConnector(limit=HTTP_TCP_CONNECTORS, enable_cleanup_closed=True),\n        )\n\n        # Request token\n        endpoint = \"/oauth2/token\"\n        api_id = \"\"\n        headers = self.headers(api_id)\n        data = {\n            \"grant_type\": \"client_credentials\",\n            \"appkey\": self._appkey,\n            \"secretkey\": self._secretkey,\n        }\n        async with self._session.post(self.host + endpoint, headers=headers, json=data) as res:\n            res.raise_for_status()\n            body = await res.json()\n            resp = Response(res.url, res.status, res.headers, body)\n\n        # Set token\n        if \"token\" not in body:\n            msg = dumps(self, endpoint, api_id, headers, data, resp)\n            raise RuntimeError(f\"Failed to get token: {msg}\")\n        token = body[\"token\"]\n        self._auth = f\"Bearer {token}\"\n        self._session.headers.update(\n            {\n                \"Content-Type\": \"application/json;charset=UTF-8\",\n                \"authorization\": self._auth,\n            }\n        )\n        self._state_http = State.CONNECTED\n        self._ready_event.set()\n\n    async def close(self) -&gt; None:\n        \"\"\"\n        Close HTTP session.\n        \"\"\"\n        self._ready_event.clear()\n        if self._session:\n            await asyncio.shield(self._session.close())\n\n        self._auth = \"\"\n        self._session = None\n\n    def token(self) -&gt; str:\n        \"\"\"\n        Returns token if available, otherwise empty string.\n\n        Raises:\n            ValueError: Invalid token.\n\n        Returns:\n            str: token\n        \"\"\"\n        if not self._auth:\n            return \"\"\n        if \"Bearer \" in self._auth:\n            return self._auth[len(\"Bearer \") :]\n        raise ValueError(f\"Invalid token: {self._auth}\")\n\n    def headers(\n        self, api_id: str, cont_yn: str = \"N\", next_key: str = \"\", headers: dict | None = None\n    ) -&gt; dict[str, str]:\n        \"\"\"\n        Generate headers for the request.\n\n        Args:\n            api_id (str): api_id in Kiwoom API\n            cont_yn (str, optional): cont_yn in Kiwoom API\n            next_key (str, optional): next_key in Kiwoom API\n            headers (dict | None, optional): headers to be updated with\n\n        Returns:\n            dict[str, str]: headers\n        \"\"\"\n        base = {\n            # 'Content-Type': 'application/json;charset=UTF-8',\n            # 'authorization': self._auth,\n            \"cont-yn\": cont_yn,\n            \"next-key\": next_key,\n            \"api-id\": api_id,\n        }\n        if headers is not None:\n            headers.update(base)\n            return headers\n        return base\n\n    async def ready(self):\n        \"\"\"\n        Wait until request limit is lifted and connection is established.\n\n        Raises:\n            RuntimeError: Connection timeout.\n        \"\"\"\n        try:\n            await asyncio.wait_for(self._ready_event.wait(), HTTP_TOTAL_TIMEOUT)\n        except asyncio.TimeoutError as err:\n            msg = f\"Connection timeout: waited for {HTTP_TOTAL_TIMEOUT} seconds.\"\n            raise RuntimeError(msg) from err\n        await self._limiter.acquire()\n\n    @debugger\n    async def post(\n        self, endpoint: str, api_id: str, headers: dict | None = None, data: dict | None = None\n    ) -&gt; aiohttp.ClientResponse:\n        \"\"\"\n        Post request to the server, but using client.request function is recommended.\n        Request limit and connection status are checked globally and automatically.\n\n        Args:\n            endpoint (str): endpoint to Kiwoom REST API server\n            api_id (str): api id\n            headers (dict | None, optional): headers of the request.\n            data (dict | None, optional): data to be sent in json format\n\n        Returns:\n            aiohttp.ClientResponse: async response from the server,\n                but this will be converted to kiwoom.http.response.Response by debugger.\n        \"\"\"\n\n        # Warn not connected\n        if not self._state_http == State.CONNECTED:\n            warnings.warn(\"Not connected, wait for timeout...\", RuntimeWarning, stacklevel=1)\n\n        # Wait connection and request limits\n        await self.ready()\n\n        # Post Request\n        if headers is None:\n            headers = self.headers(api_id)\n        return await self._session.post(self.host + endpoint, headers=headers, json=data)\n\n    async def request(\n        self, endpoint: str, api_id: str, headers: dict | None = None, data: dict | None = None\n    ) -&gt; Response:\n        \"\"\"\n        Requests to the server and returns response with error handling.\n\n        Args:\n            endpoint (str): endpoint of the server\n            api_id (str): api id\n            headers (dict | None, optional): headers of the request. Defaults to None.\n            data (dict | None, optional): data of the request. Defaults to None.\n\n        Raises:\n            RuntimeError: RuntimeError when return_code is not in [0, 3, 20]\n\n        Returns:\n            Response: response wrapped by kiwoom.http.response.Response\n        \"\"\"\n\n        res: Response = await self.post(endpoint, api_id, headers=headers, data=data)\n        body = res.json()\n        if \"return_code\" in body:\n            match body[\"return_code\"]:\n                case 0 | 20:\n                    # 0: Success\n                    # 20 : No Data\n                    return res\n                case 3:\n                    # 3 : Token Expired\n                    print(\"Token expired, trying to refresh token...\")\n                    await self.connect(self._appkey, self._secretkey)\n                    return await self.request(endpoint, api_id, headers=headers, data=data)\n\n        # Request Failure\n        return_code = body[\"return_code\"]\n        err = f\"\\nRequest failed with {return_code=}, not in {{'0', '3', '20'}}.\"\n        if not self.debugging:\n            msg = dumps(self, endpoint, api_id, headers, data, res)\n            raise RuntimeError(msg + err)\n        raise RuntimeError(err)\n\n    async def request_until(\n        self,\n        should_continue: Callable,\n        endpoint: str,\n        api_id: str,\n        headers: dict | None = None,\n        data: dict | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Request until 'cont-yn' in response header is 'Y',\n        and should_continue(body) evaluates to True.\n\n        Args:\n            should_continue (Callable):\n                callable that takes body(dict) and\n                returns boolean value to request again or not\n            endpoint (str):\n                endpoint of the server\n            api_id (str):\n                api id\n            headers (dict | None, optional):\n                headers of the request. Defaults to None.\n            data (dict | None, optional):\n                data of the request. Defaults to None.\n\n        Returns:\n            dict: response body\n        \"\"\"\n\n        # Initial request\n        res = await self.request(endpoint, api_id, headers=headers, data=data)\n        body = res.json()\n\n        # If condition to chain is not met\n        if callable(should_continue) and not should_continue(body):\n            return body\n\n        # Extract list data only\n        bodies = dict()\n        for key in body.keys():\n            if isinstance(body[key], list):\n                bodies[key] = [body[key]]\n                continue\n            bodies[key] = body[key]\n\n        # Rercursive call\n        while res.headers.get(\"cont-yn\") == \"Y\" and should_continue(body):\n            next_key = res.headers.get(\"next-key\")\n            headers = self.headers(api_id, cont_yn=\"Y\", next_key=next_key, headers=headers)\n\n            # Continue request\n            res = await self.request(endpoint, api_id, headers=headers, data=data)\n            body = res.json()\n\n            # Append list data\n            for key in body.keys():\n                if isinstance(body[key], list):\n                    bodies[key].append(body[key])\n\n        # Flatten list data as if it was one list\n        for key in bodies:\n            if isinstance(bodies[key], list):\n                bodies[key] = list(chain.from_iterable(bodies[key]))\n        return bodies\n</code></pre>"},{"location":"api/#kiwoom.http.client.Client.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host = host\n</code></pre>"},{"location":"api/#kiwoom.http.client.Client.debugging","title":"debugging  <code>instance-attribute</code>","text":"<pre><code>debugging = False\n</code></pre>"},{"location":"api/#kiwoom.http.client.Client.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(appkey, secretkey)\n</code></pre> <p>Connect to Kiwoom REST API server and receive token.</p> <p>Parameters:</p> Name Type Description Default <code>appkey</code> <code>str</code> <p>file path or raw appkey</p> required <code>secretkey</code> <code>str</code> <p>file path or raw secretkey</p> required Source code in <code>kiwoom/http/client.py</code> <pre><code>async def connect(self, appkey: str, secretkey: str) -&gt; None:\n    \"\"\"\n    Connect to Kiwoom REST API server and receive token.\n\n    Args:\n        appkey (str): file path or raw appkey\n        secretkey (str): file path or raw secretkey\n    \"\"\"\n    if isfile(appkey):\n        with open(appkey, \"r\") as f:\n            self._appkey = f.read().strip()\n    if isfile(secretkey):\n        with open(secretkey, \"r\") as f:\n            self._secretkey = f.read().strip()\n\n    # Already connected\n    if self._session and not self._session.closed:\n        return\n\n    # Establish HTTP session\n    self._ready_event.clear()\n    self._session = ClientSession(\n        timeout=aiohttp.ClientTimeout(\n            total=HTTP_TOTAL_TIMEOUT,\n            sock_connect=HTTP_CONNECT_TIMEOUT,\n            sock_read=HTTP_READ_TIMEOUT,\n        ),\n        connector=aiohttp.TCPConnector(limit=HTTP_TCP_CONNECTORS, enable_cleanup_closed=True),\n    )\n\n    # Request token\n    endpoint = \"/oauth2/token\"\n    api_id = \"\"\n    headers = self.headers(api_id)\n    data = {\n        \"grant_type\": \"client_credentials\",\n        \"appkey\": self._appkey,\n        \"secretkey\": self._secretkey,\n    }\n    async with self._session.post(self.host + endpoint, headers=headers, json=data) as res:\n        res.raise_for_status()\n        body = await res.json()\n        resp = Response(res.url, res.status, res.headers, body)\n\n    # Set token\n    if \"token\" not in body:\n        msg = dumps(self, endpoint, api_id, headers, data, resp)\n        raise RuntimeError(f\"Failed to get token: {msg}\")\n    token = body[\"token\"]\n    self._auth = f\"Bearer {token}\"\n    self._session.headers.update(\n        {\n            \"Content-Type\": \"application/json;charset=UTF-8\",\n            \"authorization\": self._auth,\n        }\n    )\n    self._state_http = State.CONNECTED\n    self._ready_event.set()\n</code></pre>"},{"location":"api/#kiwoom.http.client.Client.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close HTTP session.</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"\n    Close HTTP session.\n    \"\"\"\n    self._ready_event.clear()\n    if self._session:\n        await asyncio.shield(self._session.close())\n\n    self._auth = \"\"\n    self._session = None\n</code></pre>"},{"location":"api/#kiwoom.http.client.Client.token","title":"token","text":"<pre><code>token()\n</code></pre> <p>Returns token if available, otherwise empty string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Invalid token.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>token</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>def token(self) -&gt; str:\n    \"\"\"\n    Returns token if available, otherwise empty string.\n\n    Raises:\n        ValueError: Invalid token.\n\n    Returns:\n        str: token\n    \"\"\"\n    if not self._auth:\n        return \"\"\n    if \"Bearer \" in self._auth:\n        return self._auth[len(\"Bearer \") :]\n    raise ValueError(f\"Invalid token: {self._auth}\")\n</code></pre>"},{"location":"api/#kiwoom.http.client.Client.headers","title":"headers","text":"<pre><code>headers(api_id, cont_yn='N', next_key='', headers=None)\n</code></pre> <p>Generate headers for the request.</p> <p>Parameters:</p> Name Type Description Default <code>api_id</code> <code>str</code> <p>api_id in Kiwoom API</p> required <code>cont_yn</code> <code>str</code> <p>cont_yn in Kiwoom API</p> <code>'N'</code> <code>next_key</code> <code>str</code> <p>next_key in Kiwoom API</p> <code>''</code> <code>headers</code> <code>dict | None</code> <p>headers to be updated with</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: headers</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>def headers(\n    self, api_id: str, cont_yn: str = \"N\", next_key: str = \"\", headers: dict | None = None\n) -&gt; dict[str, str]:\n    \"\"\"\n    Generate headers for the request.\n\n    Args:\n        api_id (str): api_id in Kiwoom API\n        cont_yn (str, optional): cont_yn in Kiwoom API\n        next_key (str, optional): next_key in Kiwoom API\n        headers (dict | None, optional): headers to be updated with\n\n    Returns:\n        dict[str, str]: headers\n    \"\"\"\n    base = {\n        # 'Content-Type': 'application/json;charset=UTF-8',\n        # 'authorization': self._auth,\n        \"cont-yn\": cont_yn,\n        \"next-key\": next_key,\n        \"api-id\": api_id,\n    }\n    if headers is not None:\n        headers.update(base)\n        return headers\n    return base\n</code></pre>"},{"location":"api/#kiwoom.http.client.Client.ready","title":"ready  <code>async</code>","text":"<pre><code>ready()\n</code></pre> <p>Wait until request limit is lifted and connection is established.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Connection timeout.</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>async def ready(self):\n    \"\"\"\n    Wait until request limit is lifted and connection is established.\n\n    Raises:\n        RuntimeError: Connection timeout.\n    \"\"\"\n    try:\n        await asyncio.wait_for(self._ready_event.wait(), HTTP_TOTAL_TIMEOUT)\n    except asyncio.TimeoutError as err:\n        msg = f\"Connection timeout: waited for {HTTP_TOTAL_TIMEOUT} seconds.\"\n        raise RuntimeError(msg) from err\n    await self._limiter.acquire()\n</code></pre>"},{"location":"api/#kiwoom.http.client.Client.post","title":"post  <code>async</code>","text":"<pre><code>post(endpoint, api_id, headers=None, data=None)\n</code></pre> <p>Post request to the server, but using client.request function is recommended. Request limit and connection status are checked globally and automatically.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>endpoint to Kiwoom REST API server</p> required <code>api_id</code> <code>str</code> <p>api id</p> required <code>headers</code> <code>dict | None</code> <p>headers of the request.</p> <code>None</code> <code>data</code> <code>dict | None</code> <p>data to be sent in json format</p> <code>None</code> <p>Returns:</p> Type Description <code>ClientResponse</code> <p>aiohttp.ClientResponse: async response from the server, but this will be converted to kiwoom.http.response.Response by debugger.</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>@debugger\nasync def post(\n    self, endpoint: str, api_id: str, headers: dict | None = None, data: dict | None = None\n) -&gt; aiohttp.ClientResponse:\n    \"\"\"\n    Post request to the server, but using client.request function is recommended.\n    Request limit and connection status are checked globally and automatically.\n\n    Args:\n        endpoint (str): endpoint to Kiwoom REST API server\n        api_id (str): api id\n        headers (dict | None, optional): headers of the request.\n        data (dict | None, optional): data to be sent in json format\n\n    Returns:\n        aiohttp.ClientResponse: async response from the server,\n            but this will be converted to kiwoom.http.response.Response by debugger.\n    \"\"\"\n\n    # Warn not connected\n    if not self._state_http == State.CONNECTED:\n        warnings.warn(\"Not connected, wait for timeout...\", RuntimeWarning, stacklevel=1)\n\n    # Wait connection and request limits\n    await self.ready()\n\n    # Post Request\n    if headers is None:\n        headers = self.headers(api_id)\n    return await self._session.post(self.host + endpoint, headers=headers, json=data)\n</code></pre>"},{"location":"api/#kiwoom.http.client.Client.request","title":"request  <code>async</code>","text":"<pre><code>request(endpoint, api_id, headers=None, data=None)\n</code></pre> <p>Requests to the server and returns response with error handling.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>endpoint of the server</p> required <code>api_id</code> <code>str</code> <p>api id</p> required <code>headers</code> <code>dict | None</code> <p>headers of the request. Defaults to None.</p> <code>None</code> <code>data</code> <code>dict | None</code> <p>data of the request. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>RuntimeError when return_code is not in [0, 3, 20]</p> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>response wrapped by kiwoom.http.response.Response</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>async def request(\n    self, endpoint: str, api_id: str, headers: dict | None = None, data: dict | None = None\n) -&gt; Response:\n    \"\"\"\n    Requests to the server and returns response with error handling.\n\n    Args:\n        endpoint (str): endpoint of the server\n        api_id (str): api id\n        headers (dict | None, optional): headers of the request. Defaults to None.\n        data (dict | None, optional): data of the request. Defaults to None.\n\n    Raises:\n        RuntimeError: RuntimeError when return_code is not in [0, 3, 20]\n\n    Returns:\n        Response: response wrapped by kiwoom.http.response.Response\n    \"\"\"\n\n    res: Response = await self.post(endpoint, api_id, headers=headers, data=data)\n    body = res.json()\n    if \"return_code\" in body:\n        match body[\"return_code\"]:\n            case 0 | 20:\n                # 0: Success\n                # 20 : No Data\n                return res\n            case 3:\n                # 3 : Token Expired\n                print(\"Token expired, trying to refresh token...\")\n                await self.connect(self._appkey, self._secretkey)\n                return await self.request(endpoint, api_id, headers=headers, data=data)\n\n    # Request Failure\n    return_code = body[\"return_code\"]\n    err = f\"\\nRequest failed with {return_code=}, not in {{'0', '3', '20'}}.\"\n    if not self.debugging:\n        msg = dumps(self, endpoint, api_id, headers, data, res)\n        raise RuntimeError(msg + err)\n    raise RuntimeError(err)\n</code></pre>"},{"location":"api/#kiwoom.http.client.Client.request_until","title":"request_until  <code>async</code>","text":"<pre><code>request_until(should_continue, endpoint, api_id, headers=None, data=None)\n</code></pre> <p>Request until 'cont-yn' in response header is 'Y', and should_continue(body) evaluates to True.</p> <p>Parameters:</p> Name Type Description Default <code>should_continue</code> <code>Callable</code> <p>callable that takes body(dict) and returns boolean value to request again or not</p> required <code>endpoint</code> <code>str</code> <p>endpoint of the server</p> required <code>api_id</code> <code>str</code> <p>api id</p> required <code>headers</code> <code>dict | None</code> <p>headers of the request. Defaults to None.</p> <code>None</code> <code>data</code> <code>dict | None</code> <p>data of the request. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>response body</p> Source code in <code>kiwoom/http/client.py</code> <pre><code>async def request_until(\n    self,\n    should_continue: Callable,\n    endpoint: str,\n    api_id: str,\n    headers: dict | None = None,\n    data: dict | None = None,\n) -&gt; dict:\n    \"\"\"\n    Request until 'cont-yn' in response header is 'Y',\n    and should_continue(body) evaluates to True.\n\n    Args:\n        should_continue (Callable):\n            callable that takes body(dict) and\n            returns boolean value to request again or not\n        endpoint (str):\n            endpoint of the server\n        api_id (str):\n            api id\n        headers (dict | None, optional):\n            headers of the request. Defaults to None.\n        data (dict | None, optional):\n            data of the request. Defaults to None.\n\n    Returns:\n        dict: response body\n    \"\"\"\n\n    # Initial request\n    res = await self.request(endpoint, api_id, headers=headers, data=data)\n    body = res.json()\n\n    # If condition to chain is not met\n    if callable(should_continue) and not should_continue(body):\n        return body\n\n    # Extract list data only\n    bodies = dict()\n    for key in body.keys():\n        if isinstance(body[key], list):\n            bodies[key] = [body[key]]\n            continue\n        bodies[key] = body[key]\n\n    # Rercursive call\n    while res.headers.get(\"cont-yn\") == \"Y\" and should_continue(body):\n        next_key = res.headers.get(\"next-key\")\n        headers = self.headers(api_id, cont_yn=\"Y\", next_key=next_key, headers=headers)\n\n        # Continue request\n        res = await self.request(endpoint, api_id, headers=headers, data=data)\n        body = res.json()\n\n        # Append list data\n        for key in body.keys():\n            if isinstance(body[key], list):\n                bodies[key].append(body[key])\n\n    # Flatten list data as if it was one list\n    for key in bodies:\n        if isinstance(bodies[key], list):\n            bodies[key] = list(chain.from_iterable(bodies[key]))\n    return bodies\n</code></pre>"},{"location":"api/#kiwoom.http.debug","title":"debug","text":""},{"location":"api/#kiwoom.http.debug.dumps","title":"dumps","text":"<pre><code>dumps(api, endpoint, api_id, headers, data, res)\n</code></pre> <p>Dump request and response to string for debugging.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>Client</code> <p>Client instance</p> required <code>endpoint</code> <code>str</code> <p>endpoint</p> required <code>api_id</code> <code>str</code> <p>api id</p> required <code>headers</code> <code>dict</code> <p>headers</p> required <code>data</code> <code>dict</code> <p>data</p> required <code>res</code> <code>Response</code> <p>wrapped response</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>description</p> Source code in <code>kiwoom/http/debug.py</code> <pre><code>def dumps(api, endpoint: str, api_id, headers: dict, data: dict, res: Response) -&gt; str:\n    \"\"\"\n    Dump request and response to string for debugging.\n\n    Args:\n        api (Client): Client instance\n        endpoint (str): endpoint\n        api_id (str): api id\n        headers (dict): headers\n        data (dict): data\n        res (Response): wrapped response\n\n    Returns:\n        str: _description_\n    \"\"\"\n    # Request\n    headers = json.dumps(\n        headers if headers is not None else api.headers(api_id), indent=4, ensure_ascii=False\n    )\n    req = \"\\n== Request ==\\n\"\n    req += f\"URL : {api.host + endpoint}\\n\"\n    req += f\"Headers : {headers}\\n\"\n    req += f\"Data : {json.dumps(data, indent=4, ensure_ascii=False)}\\n\"\n\n    # Response\n    headers = json.dumps(\n        {key: res.headers.get(key) for key in [\"next-key\", \"cont-yn\", \"api-id\"]},\n        indent=4,\n        ensure_ascii=False,\n    )\n    resp = \"== Response ==\\n\"\n    resp += f\"Code : {res.status}\\n\"\n    resp += f\"Headers : {headers}\\n\"\n    resp += f\"Response : {json.dumps(res.json(), indent=4, ensure_ascii=False)}\\n\"\n    return req + resp\n</code></pre>"},{"location":"api/#kiwoom.http.debug.debugger","title":"debugger","text":"<pre><code>debugger(fn)\n</code></pre> <p>Debugger decorator for Client.post method. Even though debugging is disabled, it will print if error occurs.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>function</code> <p>function to be decorated</p> required <p>Raises:</p> Type Description <code>err</code> <p>propagate HTTPException from original function</p> <p>Returns:</p> Name Type Description <code>Response</code> <code>Callable</code> <p>wrapped response</p> Source code in <code>kiwoom/http/debug.py</code> <pre><code>def debugger(fn) -&gt; Callable:\n    \"\"\"\n    Debugger decorator for Client.post method.\n    Even though debugging is disabled, it will print if error occurs.\n\n    Args:\n        fn (function): function to be decorated\n\n    Raises:\n        err: propagate HTTPException from original function\n\n    Returns:\n        Response: wrapped response\n    \"\"\"\n\n    @functools.wraps(fn)\n    async def wrapper(api, endpoint: str, api_id: str, headers: dict, data: dict) -&gt; Response:\n        res: ClientResponse = await fn(api, endpoint, api_id, headers, data)\n        async with res:\n            # Async to sync Response\n            resp = Response(\n                url=res.url, status=res.status, headers=res.headers, body=await res.json()\n            )\n\n            # Debugging\n            if api.debugging:\n                print(dumps(api, endpoint, api_id, headers, data, resp))\n\n            try:\n                res.raise_for_status()\n            except HTTPException as err:\n                # Always debug when error occurs\n                if not api.debugging:\n                    print(dumps(api, endpoint, api_id, headers, data, resp))\n                raise err\n        return resp\n\n    return wrapper\n</code></pre>"},{"location":"api/#kiwoom.http.response","title":"response","text":""},{"location":"api/#kiwoom.http.response.Response","title":"Response","text":"<p>Response wrapper for aiohttp.ClientResponse</p> Source code in <code>kiwoom/http/response.py</code> <pre><code>class Response:\n    \"\"\"\n    Response wrapper for aiohttp.ClientResponse\n    \"\"\"\n\n    def __init__(self, url: str, status: int, headers: dict, body: dict):\n        \"\"\"\n        Simply wrap aiohttp.ClientResponse to escape from async context.\n\n        Args:\n            url (str): url of the response\n            status (int): status code of the response\n            headers (dict): headers of the response\n            body (dict): body of the response\n        \"\"\"\n\n        self.url = url\n        self.status = status\n        self.headers = headers\n        self.body = body\n\n    def json(self) -&gt; dict:\n        \"\"\"\n        Returns already parsed body.\n\n        Returns:\n            dict: body in json format\n        \"\"\"\n        return self.body\n</code></pre>"},{"location":"api/#kiwoom.http.response.Response.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"api/#kiwoom.http.response.Response.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status = status\n</code></pre>"},{"location":"api/#kiwoom.http.response.Response.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers = headers\n</code></pre>"},{"location":"api/#kiwoom.http.response.Response.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body = body\n</code></pre>"},{"location":"api/#kiwoom.http.response.Response.json","title":"json","text":"<pre><code>json()\n</code></pre> <p>Returns already parsed body.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>body in json format</p> Source code in <code>kiwoom/http/response.py</code> <pre><code>def json(self) -&gt; dict:\n    \"\"\"\n    Returns already parsed body.\n\n    Returns:\n        dict: body in json format\n    \"\"\"\n    return self.body\n</code></pre>"},{"location":"api/#kiwoom.http.socket","title":"socket","text":""},{"location":"api/#kiwoom.http.socket.Socket","title":"Socket","text":"Source code in <code>kiwoom/http/socket.py</code> <pre><code>class Socket:\n    REAL = \"wss://api.kiwoom.com:10000\"\n    MOCK = \"wss://mockapi.kiwoom.com:10000\"  # KRX Only\n    ENDPOINT = \"/api/dostk/websocket\"\n\n    def __init__(self, url: str, queue: asyncio.Queue):\n        \"\"\"\n        Initialize Socket class.\n\n        Args:\n            url (str): url of Kiwoom websocket server\n            queue (asyncio.Queue): queue to put received data\n        \"\"\"\n        self.url = url\n        self._queue = queue\n        self._session: ClientSession | None = None\n        self._websocket: ClientWebSocketResponse | None = None\n\n        self._state = State.CLOSED\n        self._state_lock = asyncio.Lock()\n        self._queue_task: asyncio.Task | None = None\n        self._stop_event = asyncio.Event()\n        self._stop_event.set()\n\n    async def connect(self, session: ClientSession, token: str):\n        \"\"\"\n        Connect to Kiwoom websocket server.\n\n        Args:\n            session (ClientSession): aiohttp ClientSession from API.connect()\n            token (str): token for authentication\n        \"\"\"\n\n        # print(\"Trying to connect websocket...\")\n        async with self._state_lock:\n            if self._state in (State.CONNECTED, State.CONNECTING):\n                return\n\n            self._state = State.CONNECTING\n            try:\n                # Close existing websocket &amp; task\n                self._stop_event.set()\n                if self._websocket and not self._websocket.closed:\n                    await self._websocket.close()\n                await cancel(self._queue_task)\n                self._queue_task = None\n\n                self._session = session\n                self._websocket = await session.ws_connect(\n                    self.url, autoping=True, heartbeat=WEBSOCKET_HEARTBEAT\n                )\n\n                self._stop_event.clear()\n                self._queue_task = asyncio.create_task(self.run(), name=\"enqueue\")\n                await self.send({\"trnm\": \"LOGIN\", \"token\": token})\n                self._state = State.CONNECTED\n\n            except Exception as err:\n                print(f\"Websocket failed to connect to {self.url}: {err}\")\n                self._state = State.CLOSED\n\n    async def close(self):\n        \"\"\"\n        Close the websocket and the task.\n        \"\"\"\n        async with self._state_lock:\n            self._stop_event.set()\n            if self._queue_task:\n                self._queue_task.cancel()\n                with contextlib.suppress(asyncio.CancelledError):\n                    await self._queue_task\n\n            if self._websocket and not self._websocket.closed:\n                with contextlib.suppress(Exception):\n                    await self._websocket.close()\n\n            self._session = None\n            self._websocket = None\n            self._queue_task = None\n\n    async def send(self, msg: str | dict) -&gt; None:\n        \"\"\"\n        Send data to Kiwoom websocket server.\n\n        Args:\n            msg (str | dict): msg should be in json format\n        \"\"\"\n        if isinstance(msg, dict):\n            # msg = json.dumps(msg)  # slow\n            msg = orjson.dumps(msg).decode(\"utf-8\")\n        await self._websocket.send_str(msg)\n\n    async def recv(self) -&gt; str:\n        \"\"\"\n        Receive data from Kiwoom websocket server and return data.\n        If message type is not str, close the websocket and raise RuntimeError.\n\n        Raises:\n            RuntimeError: Websocket Connection Error\n\n        Returns:\n            str: received json formatted data from websocket\n        \"\"\"\n        try:\n            return await self._websocket.receive_str()\n        except WSMessageTypeError as err:\n            msg = await self._websocket.receive()\n            if msg.type == WSMsgType.BINARY:\n                msg.data = msg.data.decode(\"utf-8\")\n            await self.close()\n            raise RuntimeError(f\"Websocket received other type than str: {msg}\") from err\n\n    async def run(self):\n        \"\"\"\n        Receive data from websocket and put data to the queue.\n        If WEBSOCKET_QUEUE_MAX_SIZE is set and queue gets full,\n        then backpressure will be applied to the websocket.\n        Run this task in background with asyncio.create_task().\n        \"\"\"\n        assert self._websocket is not None\n        try:\n            while not self._stop_event.is_set():\n                await self._queue.put(await self.recv())\n\n        except Exception as e:\n            print(f\"Failed to receive message: {e}\")\n            await self.close()\n</code></pre>"},{"location":"api/#kiwoom.http.socket.Socket.REAL","title":"REAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REAL = 'wss://api.kiwoom.com:10000'\n</code></pre>"},{"location":"api/#kiwoom.http.socket.Socket.MOCK","title":"MOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MOCK = 'wss://mockapi.kiwoom.com:10000'\n</code></pre>"},{"location":"api/#kiwoom.http.socket.Socket.ENDPOINT","title":"ENDPOINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENDPOINT = '/api/dostk/websocket'\n</code></pre>"},{"location":"api/#kiwoom.http.socket.Socket.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"api/#kiwoom.http.socket.Socket.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(session, token)\n</code></pre> <p>Connect to Kiwoom websocket server.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>ClientSession</code> <p>aiohttp ClientSession from API.connect()</p> required <code>token</code> <code>str</code> <p>token for authentication</p> required Source code in <code>kiwoom/http/socket.py</code> <pre><code>async def connect(self, session: ClientSession, token: str):\n    \"\"\"\n    Connect to Kiwoom websocket server.\n\n    Args:\n        session (ClientSession): aiohttp ClientSession from API.connect()\n        token (str): token for authentication\n    \"\"\"\n\n    # print(\"Trying to connect websocket...\")\n    async with self._state_lock:\n        if self._state in (State.CONNECTED, State.CONNECTING):\n            return\n\n        self._state = State.CONNECTING\n        try:\n            # Close existing websocket &amp; task\n            self._stop_event.set()\n            if self._websocket and not self._websocket.closed:\n                await self._websocket.close()\n            await cancel(self._queue_task)\n            self._queue_task = None\n\n            self._session = session\n            self._websocket = await session.ws_connect(\n                self.url, autoping=True, heartbeat=WEBSOCKET_HEARTBEAT\n            )\n\n            self._stop_event.clear()\n            self._queue_task = asyncio.create_task(self.run(), name=\"enqueue\")\n            await self.send({\"trnm\": \"LOGIN\", \"token\": token})\n            self._state = State.CONNECTED\n\n        except Exception as err:\n            print(f\"Websocket failed to connect to {self.url}: {err}\")\n            self._state = State.CLOSED\n</code></pre>"},{"location":"api/#kiwoom.http.socket.Socket.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the websocket and the task.</p> Source code in <code>kiwoom/http/socket.py</code> <pre><code>async def close(self):\n    \"\"\"\n    Close the websocket and the task.\n    \"\"\"\n    async with self._state_lock:\n        self._stop_event.set()\n        if self._queue_task:\n            self._queue_task.cancel()\n            with contextlib.suppress(asyncio.CancelledError):\n                await self._queue_task\n\n        if self._websocket and not self._websocket.closed:\n            with contextlib.suppress(Exception):\n                await self._websocket.close()\n\n        self._session = None\n        self._websocket = None\n        self._queue_task = None\n</code></pre>"},{"location":"api/#kiwoom.http.socket.Socket.send","title":"send  <code>async</code>","text":"<pre><code>send(msg)\n</code></pre> <p>Send data to Kiwoom websocket server.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str | dict</code> <p>msg should be in json format</p> required Source code in <code>kiwoom/http/socket.py</code> <pre><code>async def send(self, msg: str | dict) -&gt; None:\n    \"\"\"\n    Send data to Kiwoom websocket server.\n\n    Args:\n        msg (str | dict): msg should be in json format\n    \"\"\"\n    if isinstance(msg, dict):\n        # msg = json.dumps(msg)  # slow\n        msg = orjson.dumps(msg).decode(\"utf-8\")\n    await self._websocket.send_str(msg)\n</code></pre>"},{"location":"api/#kiwoom.http.socket.Socket.recv","title":"recv  <code>async</code>","text":"<pre><code>recv()\n</code></pre> <p>Receive data from Kiwoom websocket server and return data. If message type is not str, close the websocket and raise RuntimeError.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Websocket Connection Error</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>received json formatted data from websocket</p> Source code in <code>kiwoom/http/socket.py</code> <pre><code>async def recv(self) -&gt; str:\n    \"\"\"\n    Receive data from Kiwoom websocket server and return data.\n    If message type is not str, close the websocket and raise RuntimeError.\n\n    Raises:\n        RuntimeError: Websocket Connection Error\n\n    Returns:\n        str: received json formatted data from websocket\n    \"\"\"\n    try:\n        return await self._websocket.receive_str()\n    except WSMessageTypeError as err:\n        msg = await self._websocket.receive()\n        if msg.type == WSMsgType.BINARY:\n            msg.data = msg.data.decode(\"utf-8\")\n        await self.close()\n        raise RuntimeError(f\"Websocket received other type than str: {msg}\") from err\n</code></pre>"},{"location":"api/#kiwoom.http.socket.Socket.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>Receive data from websocket and put data to the queue. If WEBSOCKET_QUEUE_MAX_SIZE is set and queue gets full, then backpressure will be applied to the websocket. Run this task in background with asyncio.create_task().</p> Source code in <code>kiwoom/http/socket.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Receive data from websocket and put data to the queue.\n    If WEBSOCKET_QUEUE_MAX_SIZE is set and queue gets full,\n    then backpressure will be applied to the websocket.\n    Run this task in background with asyncio.create_task().\n    \"\"\"\n    assert self._websocket is not None\n    try:\n        while not self._stop_event.is_set():\n            await self._queue.put(await self.recv())\n\n    except Exception as e:\n        print(f\"Failed to receive message: {e}\")\n        await self.close()\n</code></pre>"},{"location":"api/#kiwoom.http.utils","title":"utils","text":""},{"location":"api/#kiwoom.http.utils.RateLimiter","title":"RateLimiter","text":"Source code in <code>kiwoom/http/utils.py</code> <pre><code>class RateLimiter:\n    def __init__(self, rps: int = REQ_LIMIT_PER_SECOND):\n        \"\"\"\n        Globally limits requests per second.\n\n        Args:\n            rps (float): requests per second\n        \"\"\"\n        self._period = 1.0 / rps\n        self._loop = asyncio.get_running_loop()\n        self._lock = asyncio.Lock()\n        self._next = 0.0\n\n    async def acquire(self):\n        async with self._lock:\n            now = self._loop.time()\n            if self._next &lt; now:\n                self._next = now\n            wait = self._next - now\n            self._next += self._period\n\n        if wait &gt; 0:\n            await asyncio.sleep(wait)\n</code></pre>"},{"location":"api/#kiwoom.http.utils.RateLimiter.acquire","title":"acquire  <code>async</code>","text":"<pre><code>acquire()\n</code></pre> Source code in <code>kiwoom/http/utils.py</code> <pre><code>async def acquire(self):\n    async with self._lock:\n        now = self._loop.time()\n        if self._next &lt; now:\n            self._next = now\n        wait = self._next - now\n        self._next += self._period\n\n    if wait &gt; 0:\n        await asyncio.sleep(wait)\n</code></pre>"},{"location":"api/#kiwoom.http.utils.wrap_async_callback","title":"wrap_async_callback","text":"<pre><code>wrap_async_callback(semaphore, callback)\n</code></pre> <p>Wrap async callback to run in async context.</p> <p>Parameters:</p> Name Type Description Default <code>semaphore</code> <code>Semaphore</code> <p>semaphore to limit the number of callbacks</p> required <code>callback</code> <code>Callable</code> <p>callback to be wrapped</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>wrapped callback</p> Source code in <code>kiwoom/http/utils.py</code> <pre><code>def wrap_async_callback(semaphore: asyncio.Semaphore, callback: Callable) -&gt; Callable:\n    \"\"\"\n    Wrap async callback to run in async context.\n\n    Args:\n        semaphore (asyncio.Semaphore): semaphore to limit the number of callbacks\n        callback (Callable): callback to be wrapped\n\n    Returns:\n        Callable: wrapped callback\n    \"\"\"\n\n    async def wrapper(msg: RealData | dict):\n        async with semaphore:\n            await callback(msg)\n\n    return wrapper\n</code></pre>"},{"location":"api/#kiwoom.http.utils.wrap_sync_callback","title":"wrap_sync_callback","text":"<pre><code>wrap_sync_callback(semaphore, callback)\n</code></pre> <p>Wrap sync callback to run in async context.</p> <p>Parameters:</p> Name Type Description Default <code>semaphore</code> <code>Semaphore</code> <p>semaphore to limit the number of callbacks</p> required <code>callback</code> <code>Callable</code> <p>callback to be wrapped</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>wrapped callback</p> Source code in <code>kiwoom/http/utils.py</code> <pre><code>def wrap_sync_callback(semaphore: asyncio.Semaphore, callback: Callable) -&gt; Callable:\n    \"\"\"\n    Wrap sync callback to run in async context.\n\n    Args:\n        semaphore (asyncio.Semaphore): semaphore to limit the number of callbacks\n        callback (Callable): callback to be wrapped\n\n    Returns:\n        Callable: wrapped callback\n    \"\"\"\n\n    async def wrapper(msg: RealData | dict):\n        async with semaphore:\n            await asyncio.get_running_loop().run_in_executor(None, callback, msg)\n\n    return wrapper\n</code></pre>"},{"location":"api/#kiwoom.http.utils.cancel","title":"cancel  <code>async</code>","text":"<pre><code>cancel(task)\n</code></pre> <p>Cancel a task if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task | None</code> <p>task to be cancelled</p> required Source code in <code>kiwoom/http/utils.py</code> <pre><code>async def cancel(task: asyncio.Task | None) -&gt; None:\n    \"\"\"\n    Cancel a task if it exists.\n\n    Args:\n        task (asyncio.Task | None): task to be cancelled\n    \"\"\"\n    if task:\n        task.cancel()\n        with contextlib.suppress(asyncio.CancelledError):\n            await task\n</code></pre>"}]}